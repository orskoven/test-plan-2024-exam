==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/CTIMySQLFINAL/src/main/java/orsk/compli/repository/auth/RefreshTokenRepository.java
==============================
package orsk.compli.repository.auth;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;
import orsk.compli.entities.RefreshToken;
import orsk.compli.entities.User;


import java.util.Optional;

@Repository("RefreshTokenJpaRepository")
public interface RefreshTokenRepository extends JpaRepository<RefreshToken, Long> {
    Optional<RefreshToken> findByToken(String token);

    int deleteByUser(User user);
}


==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/CTIMySQLFINAL/src/main/java/orsk/compli/repository/auth/RoleRepository.java
==============================
package orsk.compli.repository.auth;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;
import orsk.compli.entities.Role;
import java.util.Optional;

@Repository("RoleJpaRepository")
public interface RoleRepository extends JpaRepository<Role, Long> {
    Optional<Role> findByName(String name);
}



==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/CTIMySQLFINAL/src/main/java/orsk/compli/repository/auth/MfaTokenRepository.java
==============================
package orsk.compli.repository.auth;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;
import orsk.compli.entities.MfaToken;
import orsk.compli.entities.User;


import java.util.Optional;

@Repository("MfaTokenJpaRepository")
public interface MfaTokenRepository extends JpaRepository<MfaToken, Long> {
    Optional<MfaToken> findByMfaCode(String mfaCode);
    Optional<MfaToken> findByMfaCodeAndUser(String mfaCode, User user);

    Optional<MfaToken> findByUserUsername(String username);
}


==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/CTIMySQLFINAL/src/main/java/orsk/compli/repository/auth/UserRepository.java
==============================
package orsk.compli.repository.auth;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;
import orsk.compli.entities.User;

import java.util.Optional;

@Repository
public interface UserRepository extends JpaRepository<User, Long> {
    Optional<User> findByUsername(String username);

    Optional<User> findByEmail(String email);

    boolean existsByUsernameOrEmail(String username, String email);

    Optional<User> findByPasswordResetTokens_Token(String token);

    @Query("SELECT u FROM User u JOIN FETCH u.roles WHERE u.email = :email")
    Optional<User> findByEmailWithRoles(@Param("email") String email);
}


==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/CTIMySQLFINAL/src/main/java/orsk/compli/repository/auth/PasswordResetTokenRepository.java
==============================
package orsk.compli.repository.auth;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;
import orsk.compli.entities.PasswordResetToken;

import java.util.Optional;

@Repository("PasswordResetTokenJpaRepository")
public interface PasswordResetTokenRepository extends JpaRepository<PasswordResetToken, Long> {
    Optional<PasswordResetToken> findByToken(String token);
}



==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/CTIMySQLFINAL/src/main/java/orsk/compli/repository/auth/VerificationTokenRepository.java
==============================
package orsk.compli.repository.auth;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;
import orsk.compli.entities.VerificationToken;
import orsk.compli.entities.User;

import java.util.Optional;

@Repository("VerificationTokenJpaRepository")
public interface VerificationTokenRepository extends JpaRepository<VerificationToken, Long> {
    Optional<VerificationToken> findByToken(String token);

    Optional<VerificationToken> findByUser(User user);

    Optional<VerificationToken> findByUserEmail(String email);
}



==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/CTIMySQLFINAL/src/main/java/orsk/compli/repository/auth/AuditLogRepository.java
==============================
package orsk.compli.repository.auth;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;
import orsk.compli.entities.AuditLog;

@Repository("AuditLogJpaRepository")
public interface AuditLogRepository extends JpaRepository<AuditLog, Long> {
}


==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/CTIMySQLFINAL/src/main/java/orsk/compli/repository/auth/PrivilegeRepository.java
==============================
package orsk.compli.repository.auth;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;
import orsk.compli.entities.Privilege;


import java.util.Optional;

@Repository("PrivilegeJpaRepository")
public interface PrivilegeRepository extends JpaRepository<Privilege, Long> {
    Optional<Privilege> findByName(String name);
}



==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/CTIMySQLFINAL/src/main/java/orsk/compli/repository/jpa/AffectedProductJpaRepository.java
==============================
package orsk.compli.repository.jpa;

import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.domain.Specification;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.JpaSpecificationExecutor;
import org.springframework.data.jpa.repository.Query;
import org.springframework.stereotype.Repository;
import orsk.compli.entities.AffectedProduct;

import java.util.List;

@Repository("jpaAffectedProductRepository")
public interface AffectedProductJpaRepository extends JpaRepository<AffectedProduct, Long>, JpaSpecificationExecutor<AffectedProduct> {

    @Query("SELECT a.productName FROM AffectedProduct a")
    List<String> findAllProductNames();

    // Find products by vendor with pagination support
    Page<AffectedProduct> findByVendor(String vendor, Pageable pageable);

    // Find products by name
    List<AffectedProduct> findByProductNameContainingIgnoreCase(String name);

    // Custom Specification for advanced querying
    static Specification<AffectedProduct> hasVendor(String vendor) {
        return (root, query, cb) -> cb.equal(root.get("vendor"), vendor);
    }

    // Custom Specification for product version
    static Specification<AffectedProduct> hasVersion(String version) {
        return (root, query, cb) -> cb.equal(root.get("version"), version);
    }
}



==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/CTIMySQLFINAL/src/main/java/orsk/compli/repository/jpa/GlobalThreatJpaRepository.java
==============================
package orsk.compli.repository.jpa;

import org.springframework.data.jpa.domain.Specification;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.JpaSpecificationExecutor;
import org.springframework.data.jpa.repository.Query;
import org.springframework.stereotype.Repository;
import orsk.compli.entities.GlobalThreat;

import java.time.LocalDate;
import java.util.List;

@Repository("GlobalThreatJpaRepository")
public interface GlobalThreatJpaRepository extends JpaRepository<GlobalThreat, Long>, JpaSpecificationExecutor<GlobalThreat> {
    @Query("SELECT g.name FROM GlobalThreat g")
    List<String> findAllThreatNames();

    // Find global threats active within a date range
    List<GlobalThreat> findByFirstDetectedBetween(LocalDate startDate, LocalDate endDate);

    // Find threats by severity level
    List<GlobalThreat> findBySeverityLevelGreaterThanEqual(int level);

    // Custom query using Specifications
    static Specification<GlobalThreat> isActive() {
        return (root, query, cb) -> cb.greaterThan(root.get("dataRetentionUntil"), LocalDate.now());
    }

    // Custom Specification for severity level
    static Specification<GlobalThreat> hasSeverityLevel(int level) {
        return (root, query, cb) -> cb.ge(root.get("severityLevel"), level);
    }
}



==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/CTIMySQLFINAL/src/main/java/orsk/compli/repository/jpa/CountryJpaRepository.java
==============================
package orsk.compli.repository.jpa;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.JpaSpecificationExecutor;
import org.springframework.data.jpa.repository.Query;
import org.springframework.stereotype.Repository;
import orsk.compli.entities.Country;

import java.util.List;

@Repository("CountryJpaRepository")
public interface CountryJpaRepository extends JpaRepository<Country, Long>, JpaSpecificationExecutor<Country> {
    @Query("SELECT c.countryName FROM Country c")
    List<String> findAllCountryNames();

}



==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/CTIMySQLFINAL/src/main/java/orsk/compli/repository/jpa/AttackVectorCategoryJpaRepository.java
==============================
package orsk.compli.repository.jpa;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;
import orsk.compli.entities.AttackVectorCategory;

@Repository("AttackVectorCategoryJpaRepository")
public interface AttackVectorCategoryJpaRepository extends JpaRepository<AttackVectorCategory, Long> {

}



==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/CTIMySQLFINAL/src/main/java/orsk/compli/repository/jpa/AttackVectorJpaRepository.java
==============================
package orsk.compli.repository.jpa;

import org.springframework.data.jpa.domain.Specification;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.JpaSpecificationExecutor;
import org.springframework.stereotype.Repository;
import orsk.compli.entities.AttackVector;
import orsk.compli.entities.AttackVectorCategory;

import java.util.List;

@Repository("AttackVectorJpaRepository")
public interface AttackVectorJpaRepository extends JpaRepository<AttackVector, Long>, JpaSpecificationExecutor<AttackVector> {

    // Find attack vectors by severity level
    List<AttackVector> findBySeverityLevelGreaterThanEqual(int level);

    // Find attack vectors by category name
    List<AttackVector> findAttackVectorByVectorCategory(AttackVectorCategory vectorCategory);

    // Custom Specification for dynamic querying
    static Specification<AttackVector> hasSeverityLevel(int level) {
        return (root, query, cb) -> cb.ge(root.get("severityLevel"), level);
    }

    // Custom Specification for category
    static Specification<AttackVector> hasCategory(String categoryName) {
        return (root, query, cb) -> cb.equal(root.join("category").get("name"), categoryName);
    }
}



==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/CTIMySQLFINAL/src/main/java/orsk/compli/repository/jpa/GeolocationJpaRepository.java
==============================
package orsk.compli.repository.jpa;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.JpaSpecificationExecutor;
import org.springframework.stereotype.Repository;
import orsk.compli.entities.Geolocation;

@Repository("GeolocationJpaRepository")
public interface GeolocationJpaRepository extends JpaRepository<Geolocation, Long>, JpaSpecificationExecutor<Geolocation> {

}



==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/CTIMySQLFINAL/src/main/java/orsk/compli/repository/jpa/ThreatActorTypeJpaRepository.java
==============================
package orsk.compli.repository.jpa;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;
import orsk.compli.entities.ThreatActorType;

@Repository("ThreatActorTypeJpaRepository")
public interface ThreatActorTypeJpaRepository extends JpaRepository<ThreatActorType, Long> {

}



==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/CTIMySQLFINAL/src/main/java/orsk/compli/repository/jpa/ThreatActorJpaRepository.java
==============================
package orsk.compli.repository.jpa;

import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.domain.Specification;
import org.springframework.data.jpa.repository.EntityGraph;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.JpaSpecificationExecutor;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;
import orsk.compli.entities.ThreatActor;

import java.util.List;
import java.util.Optional;

/**
 * Fortune-10-grade JPA Repository for managing ThreatActor entities with enhanced capabilities.
 */
@Repository("ThreatActorJpaRepository")
public interface ThreatActorJpaRepository extends JpaRepository<ThreatActor, Long>, JpaSpecificationExecutor<ThreatActor> {

    /**
     * Find ThreatActors by their name.
     *
     * @param actorName The name of the ThreatActor.
     * @return List of ThreatActors with the specified name.
     */
    List<ThreatActor> findByActorName(String actorName);

    /**
     * Find ThreatActors by their origin country's ISO country code.
     *
     * @param countryCode The ISO country code.
     * @return List of ThreatActors from the specified country.
     */
    List<ThreatActor> findByOriginCountryCountryCode(String countryCode);

    /**
     * Fetch all ThreatActors with their attack vectors eagerly loaded.
     *
     * @return List of ThreatActors with attack vectors.
     */
    @Query("SELECT t FROM ThreatActor t LEFT JOIN FETCH t.attackVectors")
    List<ThreatActor> findAllActorsWithAttackVectors();

    /**
     * Fetch a ThreatActor by ID, eagerly loading type, originCountry, category, and attackVectors.
     *
     * @param id The ID of the ThreatActor.
     * @return Optional ThreatActor with details.
     */
    @EntityGraph(attributePaths = {"type", "originCountry", "category", "attackVectors"})
    Optional<ThreatActor> findById(Integer id);

    /**
     * Fetch all ThreatActors, eagerly loading type, originCountry, category, and attackVectors.
     *
     * @return List of ThreatActors with details.
     */
    @Override
    @EntityGraph(attributePaths = {"type", "originCountry", "category", "attackVectors"})
    List<ThreatActor> findAll();

    /**
     * Dynamic query for filtering by type.
     */
    static Specification<ThreatActor> hasType(String typeName) {
        return (root, query, cb) -> cb.equal(root.join("type").get("name"), typeName);
    }

    /**
     * Dynamic query for filtering by origin country.
     */
    static Specification<ThreatActor> hasOriginCountry(String countryCode) {
        return (root, query, cb) -> cb.equal(root.join("originCountry").get("code"), countryCode);
    }

    /**
     * Paginated list of ThreatActors matching the specification.
     */
    Page<ThreatActor> findAll(Specification<ThreatActor> spec, Pageable pageable);

    /**
     * Count ThreatActors matching a specification.
     */
    long count(Specification<ThreatActor> spec);

    /**
     * Fetch ThreatActors by type and origin country with eager loading.
     */
    @Query("SELECT t FROM ThreatActor t " +
            "LEFT JOIN FETCH t.type " +
            "LEFT JOIN FETCH t.originCountry " +
            "LEFT JOIN FETCH t.category " +
            "LEFT JOIN FETCH t.attackVectors " +
            "WHERE t.type.typeName = :typeName AND t.originCountry.countryCode = :countryCode")
    List<ThreatActor> findByTypeAndCountry(@Param("typeName") String typeName, @Param("countryCode") String countryCode);
    /**
     * Fetch ThreatActors by attack vector name (advanced filtering).
     */
    @Query("""
           SELECT DISTINCT t
           FROM ThreatActor t
           LEFT JOIN FETCH t.attackVectors av
           LEFT JOIN FETCH t.type
           LEFT JOIN FETCH t.originCountry
           WHERE av.vectorName LIKE %:vectorName%
           """)
    List<ThreatActor> findByAttackVectorName(String vectorName);
}


==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/CTIMySQLFINAL/src/main/java/orsk/compli/repository/jpa/ThreatCategoryJpaRepository.java
==============================
package orsk.compli.repository.jpa;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.JpaSpecificationExecutor;
import org.springframework.stereotype.Repository;
import orsk.compli.entities.ThreatCategory;

@Repository("ThreatCategoryJpaRepository")
public interface ThreatCategoryJpaRepository extends JpaRepository<ThreatCategory, Long>, JpaSpecificationExecutor<ThreatCategory> {

}



==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/CTIMySQLFINAL/src/main/java/orsk/compli/repository/jpa/VulnerabilityJpaRepository.java
==============================
package orsk.compli.repository.jpa;

import org.springframework.data.jpa.domain.Specification;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.JpaSpecificationExecutor;
import org.springframework.stereotype.Repository;
import orsk.compli.entities.Vulnerability;

import java.time.LocalDate;
import java.util.List;
import java.util.Optional;

@Repository("VulnerabilityJpaRepository")
public interface VulnerabilityJpaRepository extends JpaRepository<Vulnerability, Long>, JpaSpecificationExecutor<Vulnerability> {

    // Find vulnerabilities by severity score
    List<Vulnerability> findBySeverityScoreGreaterThanEqual(double score);

    // Find vulnerabilities by CVE ID
    Optional<Vulnerability> findByCveId(String cveId);

    // Find vulnerabilities published after a certain date
    List<Vulnerability> findByPublishedDateAfter(LocalDate date);

    // Custom Specification for complex queries
    static Specification<Vulnerability> isExploitedAndSevere(boolean exploited, double score) {
        return (root, query, cb) -> cb.and(
                cb.equal(root.get("exploited"), exploited),
                cb.ge(root.get("severityScore"), score)
        );
    }

    // Custom Specification for publication date
    static Specification<Vulnerability> publishedAfter(LocalDate date) {
        return (root, query, cb) -> cb.greaterThan(root.get("publishedDate"), date);
    }
}



==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/CTIMySQLFINAL/src/main/java/orsk/compli/util/TokenValidator.java
==============================
/*package orsk.compli.util;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Component;
import org.springframework.web.client.RestTemplate;
import orsk.compli.config.AuthServiceConfig;

import java.util.Map;

@Component
public class TokenValidator {

    @Autowired
    private AuthServiceConfig authServiceConfig;

    @Autowired
    private RestTemplate restTemplate;

    public boolean isValidToken(String token) {
        String url = authServiceConfig.getAuthServiceUrl() + "/validate";
        try {
            ResponseEntity<Map> response = restTemplate.postForEntity(
                    url, 
                    Map.of("token", token), 
                    Map.class
            );
            return response.getBody() != null && Boolean.TRUE.equals(response.getBody().get("valid"));
        } catch (Exception ex) {
            return false;
        }
    }
}

 */


==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/CTIMySQLFINAL/src/main/java/orsk/compli/util/StringToLocalDateConverter.java
==============================
package orsk.compli.util;

import org.springframework.core.convert.converter.Converter;
import org.springframework.data.convert.ReadingConverter;

import java.time.LocalDate;
import java.time.format.DateTimeFormatter;

@ReadingConverter
public class StringToLocalDateConverter implements Converter<String, LocalDate> {
    private static final DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd");

    @Override
    public LocalDate convert(String source) {
        return LocalDate.parse(source, formatter);
    }
}


==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/CTIMySQLFINAL/src/main/java/orsk/compli/config/JacksonConfig.java
==============================
package orsk.compli.config;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.datatype.hibernate5.Hibernate5Module;
import com.fasterxml.jackson.datatype.jsr310.JavaTimeModule;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class JacksonConfig {

    @Bean
    public ObjectMapper objectMapper() {
        ObjectMapper objectMapper = new ObjectMapper();
        objectMapper.registerModule(new Hibernate5Module());
        objectMapper.registerModule(new JavaTimeModule());
        return objectMapper;
    }
}


==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/CTIMySQLFINAL/src/main/java/orsk/compli/config/AuthServiceConfig.java
==============================
/*package orsk.compli.config;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Configuration;

@Configuration
public class AuthServiceConfig {
    @Value("${auth.service.url}")
    private String authServiceUrl;

    public String getAuthServiceUrl() {
        return authServiceUrl;
    }
}

 */


==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/CTIMySQLFINAL/src/main/java/orsk/compli/config/AppConfig.java
==============================
package orsk.compli.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.client.RestTemplate;

@Configuration
public class AppConfig {

    @Bean
    public RestTemplate restTemplate() {
        return new RestTemplate();
    }
}


==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/CTIMySQLFINAL/src/main/java/orsk/compli/security/SecurityConfig.java
==============================
package orsk.compli.security;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.http.HttpMethod;
import org.springframework.security.access.AccessDecisionManager;
import org.springframework.security.access.hierarchicalroles.RoleHierarchy;
import org.springframework.security.access.hierarchicalroles.RoleHierarchyImpl;
import org.springframework.security.access.vote.AffirmativeBased;
import org.springframework.security.access.vote.RoleHierarchyVoter;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration;
import org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.web.configurers.AbstractHttpConfigurer;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;
import org.springframework.web.cors.CorsConfiguration;
import org.springframework.web.cors.UrlBasedCorsConfigurationSource;
import org.springframework.web.filter.CorsFilter;

import java.util.Arrays;
import java.util.List;

import static org.springframework.security.config.Customizer.withDefaults;

@Configuration
@EnableWebSecurity
//@EnableMethodSecurity(prePostEnabled = true)
public class SecurityConfig {

    private final JwtAuthenticationEntryPoint unauthorizedHandler;

    public SecurityConfig(JwtAuthenticationEntryPoint unauthorizedHandler) {
        this.unauthorizedHandler = unauthorizedHandler;
    }

    @Bean
    public JwtAuthenticationFilter jwtAuthenticationFilter() {
        return new JwtAuthenticationFilter();
    }

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
                .cors(withDefaults())
                .csrf(AbstractHttpConfigurer::disable)
                .headers(headers -> headers
                        .contentSecurityPolicy(csp -> csp
                                .policyDirectives("default-src 'self'; script-src 'self'; style-src 'self'; img-src 'self';")
                        )
                        .httpStrictTransportSecurity(hsts -> hsts
                                .includeSubDomains(true)
                                .maxAgeInSeconds(31536000)
                        )
                )
                .sessionManagement(session -> session
                        .sessionCreationPolicy(SessionCreationPolicy.STATELESS)
                )
                .authorizeHttpRequests(auth -> auth
                        .requestMatchers(HttpMethod.OPTIONS, "/**").permitAll()
                        .requestMatchers("/api/auth/**").permitAll()
                        .anyRequest().authenticated()
                )
                .exceptionHandling(exception -> exception
                        .authenticationEntryPoint(unauthorizedHandler)
                );

        http.addFilterBefore(jwtAuthenticationFilter(), UsernamePasswordAuthenticationFilter.class);

        return http.build();
    }

    @Bean
    public AuthenticationManager authenticationManager(AuthenticationConfiguration authenticationConfiguration) throws Exception {
        return authenticationConfiguration.getAuthenticationManager();
    }
    @Bean
    public RoleHierarchy roleHierarchy() {
        RoleHierarchyImpl roleHierarchy = new RoleHierarchyImpl();
        roleHierarchy.setHierarchy("ROLE_ADMIN > ROLE_MANAGER > ROLE_USER");
        return roleHierarchy;
    }

    @Bean
    public AccessDecisionManager accessDecisionManager(RoleHierarchy roleHierarchy) {
        return new AffirmativeBased(Arrays.asList(new RoleHierarchyVoter(roleHierarchy)));
    }
    public void logUserRoles() {
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        if (authentication != null) {
            System.out.println("Authenticated User: " + authentication.getName());
            System.out.println("Authorities: " + authentication.getAuthorities());
        }
    }

    @Bean
    public CorsFilter corsFilter() {
        CorsConfiguration configuration = new CorsConfiguration();
        configuration.setAllowedOrigins(List.of(
                "http://localhost:5173",
                "http://localhost:5174",
                "https://witty-beach-07b060e1e-preview.westus2.4.azurestaticapps.net" // Added production URL
        ));
        configuration.setAllowedMethods(Arrays.asList("GET", "POST", "PUT", "DELETE", "OPTIONS"));
        configuration.setAllowedHeaders(List.of("*"));
        configuration.setAllowCredentials(true); // Allows cookies or authorization headers
        configuration.setMaxAge(3600L); // Cache preflight response for 1 hour

        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
        source.registerCorsConfiguration("/**", configuration);

        return new CorsFilter(source);
    }
}


==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/CTIMySQLFINAL/src/main/java/orsk/compli/security/JwtAuthenticationEntryPoint.java
==============================
package orsk.compli.security;

import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.springframework.security.core.AuthenticationException;
import org.springframework.security.web.AuthenticationEntryPoint;
import org.springframework.stereotype.Component;

import java.io.IOException;

@Component
public class JwtAuthenticationEntryPoint implements AuthenticationEntryPoint {

    @Override
    public void commence(HttpServletRequest request,
                         HttpServletResponse response,
                         AuthenticationException authException) throws IOException, ServletException {
        response.sendError(HttpServletResponse.SC_UNAUTHORIZED, authException.getMessage());
    }
}


==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/CTIMySQLFINAL/src/main/java/orsk/compli/security/JwtAuthenticationFilter.java
==============================
package orsk.compli.security;

import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.web.authentication.WebAuthenticationDetailsSource;
import org.springframework.web.filter.OncePerRequestFilter;
import orsk.compli.service.auth.CustomUserDetailsService;

import java.io.IOException;

public class JwtAuthenticationFilter extends OncePerRequestFilter {

    @Autowired
    private JwtTokenProvider tokenProvider;

    @Autowired
    private CustomUserDetailsService customUserDetailsService;

    @Override
    protected void doFilterInternal(HttpServletRequest request,
                                    HttpServletResponse response,
                                    FilterChain filterChain) throws ServletException, IOException {

        try {
            String jwt = getJwtFromRequest(request);

            if (jwt != null && tokenProvider.validateToken(jwt)) {
                String username = tokenProvider.getUsernameFromJWT(jwt);

                UserDetails userDetails = customUserDetailsService.loadUserByUsername(username);

                var authentication = new UsernamePasswordAuthenticationToken(
                        userDetails, null, userDetails.getAuthorities());

                authentication.setDetails(new WebAuthenticationDetailsSource()
                        .buildDetails(request));

                SecurityContextHolder.getContext().setAuthentication(authentication);
            }
        } catch (Exception ex) {
            logger.error("Could not set user authentication in security context", ex);
        }

        filterChain.doFilter(request, response);
    }

    private String getJwtFromRequest(HttpServletRequest request) {
        String bearerToken = request.getHeader("Authorization");
        if (bearerToken != null && bearerToken.startsWith("Bearer ")) {
            return bearerToken.substring(7);
        }
        return null;
    }
}


==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/CTIMySQLFINAL/src/main/java/orsk/compli/security/JwtTokenProvider.java
==============================
package orsk.compli.security;

import io.jsonwebtoken.Claims;
import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.SignatureAlgorithm;
import io.jsonwebtoken.security.Keys;
import jakarta.annotation.PostConstruct;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.security.core.Authentication;
import org.springframework.stereotype.Component;

import java.security.Key;
import java.util.Date;

@Component
public class JwtTokenProvider {

    @Value("${jwt.secret}")
    private String jwtSecret;

    @Value("${jwt.expiration.ms}")
    private int jwtExpirationInMs;

    private Key key;

    @PostConstruct
    public void init() {
        // Generate a secure key for HS512 using the configured jwtSecret
        if (jwtSecret != null && jwtSecret.length() >= 64) { // Ensure sufficient length for HS512
            key = Keys.hmacShaKeyFor(jwtSecret.getBytes());
        } else {
            throw new IllegalArgumentException("JWT secret key must be at least 64 characters long");
        }
    }

    public String generateToken(Authentication authentication) {
        String username = authentication.getName();
        Date now = new Date();
        Date expiryDate = new Date(now.getTime() + jwtExpirationInMs);

        return Jwts.builder()
                .setSubject(username)
                .setIssuedAt(now)
                .setExpiration(expiryDate)
                .signWith(key, SignatureAlgorithm.HS512)
                .compact();
    }

    public String generateTokenFromUsername(String username) {
        Date now = new Date();
        Date expiryDate = new Date(now.getTime() + jwtExpirationInMs);

        return Jwts.builder()
                .setSubject(username)
                .setIssuedAt(now)
                .setExpiration(expiryDate)
                .signWith(key, SignatureAlgorithm.HS512)
                .compact();
    }

    public String getUsernameFromJWT(String token) {
        Claims claims = Jwts.parserBuilder()
                .setSigningKey(key)
                .build()
                .parseClaimsJws(token)
                .getBody();

        return claims.getSubject();
    }

    public boolean validateToken(String authToken) {
        try {
            Jwts.parserBuilder()
                    .setSigningKey(key)
                    .build()
                    .parseClaimsJws(authToken);
            return true;
        } catch (Exception ex) {
            // Log the exception or handle it as needed
        }
        return false;
    }
}


==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/CTIMySQLFINAL/src/main/java/orsk/compli/controller/auth/AdminController.java
==============================
package orsk.compli.controller.auth;


import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;
import orsk.compli.service.auth.AdminService;

import java.util.List;

@RestController
@RequestMapping("/api/admin")
public class AdminController {

    @Autowired
    private AdminService adminService;

    @PutMapping("/enable-user/{userId}")
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<?> enableUser(@PathVariable Long userId) {
        adminService.enableUser(userId);
        return ResponseEntity.ok().body("User enabled successfully");
    }

    @PutMapping("/disable-user/{userId}")
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<?> disableUser(@PathVariable Long userId) {
        adminService.disableUser(userId);
        return ResponseEntity.ok().body("User disabled successfully");
    }

    @PutMapping("/update-roles/{userId}")
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<?> updateUserRoles(@PathVariable Long userId, @RequestBody List<String> roles) {
        adminService.updateUserRoles(userId, roles);
        return ResponseEntity.ok().body("User roles updated successfully");
    }

    @GetMapping("/users")
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<?> getAllUsers() {
        return ResponseEntity.ok().body(adminService.getAllUsers());
    }

    @DeleteMapping("/delete-user/{userId}")
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<?> deleteUser(@PathVariable Long userId) {
        adminService.deleteUser(userId);
        return ResponseEntity.ok().body("User deleted successfully");
    }
}


==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/CTIMySQLFINAL/src/main/java/orsk/compli/controller/auth/AuthController.java
==============================
package orsk.compli.controller.auth;

import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.authentication.BadCredentialsException;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.context.request.RequestContextHolder;
import org.springframework.web.context.request.ServletRequestAttributes;
import orsk.compli.dtos.auth.*;
import orsk.compli.entities.User;
import orsk.compli.exception.auth.InvalidTokenException;
import orsk.compli.exception.auth.MfaRequiredException;
import orsk.compli.repository.auth.UserRepository;
import orsk.compli.service.auth.AuditLogService;
import orsk.compli.service.auth.AuthService;
import orsk.compli.service.auth.MfaTokenService;

@RestController
@RequestMapping("/api/auth")
@RequiredArgsConstructor
@Slf4j
@Tag(name = "Authentication API", description = "Endpoints for user authentication and related operations")
public class AuthController {

    private final AuthService authService;
    private final UserRepository userRepository;
    private final MfaTokenService mfaTokenService;
    private final AuditLogService auditLogService;

    @PostMapping("/register")
    @Operation(summary = "Register a new user", description = "Registers a user with the provided details and sends verification instructions.")
    public ResponseEntity<String> registerUser(@Valid @RequestBody RegistrationRequest registrationRequest) {
        if (userRepository.existsByUsernameOrEmail(registrationRequest.getEmail(), registrationRequest.getUsername())) {
            log.warn("Attempt to register with existing email/username: email={}, username={}",
                    registrationRequest.getEmail(), registrationRequest.getUsername());
            return ResponseEntity.status(HttpStatus.CONFLICT)
                    .body("Email or Username already exists.");
        }
        authService.registerUser(registrationRequest);
        return ResponseEntity.status(HttpStatus.CREATED)
                .body("User registered successfully. Please check your email for verification instructions.");
    }

    @PostMapping("/login")
    @Operation(summary = "User login", description = "Authenticates the user and returns a JWT token.")
    public ResponseEntity<JwtAuthenticationResponse> authenticateUser(@Valid @RequestBody LoginRequest loginRequest) {
        try {
            JwtAuthenticationResponse response = authService.authenticateUser(loginRequest);
            return ResponseEntity.ok(response);
        } catch (MfaRequiredException e) {
            log.info("MFA required for email: {}", loginRequest.getEmail());
            return ResponseEntity.status(HttpStatus.FORBIDDEN)
                    .body(JwtAuthenticationResponse.ofMessage("MFA required"));
        } catch (BadCredentialsException e) {
            log.info("Invalid credentials for email: {}", loginRequest.getEmail());
            return ResponseEntity.status(HttpStatus.UNAUTHORIZED)
                    .body(JwtAuthenticationResponse.ofMessage("Invalid credentials"));
        }
    }

    @PostMapping("/refresh-token")
    @Operation(summary = "Refresh JWT token", description = "Generates a new JWT token using a valid refresh token.")
    public ResponseEntity<JwtAuthenticationResponse> refreshToken(@Valid @RequestBody TokenRefreshRequest request) {
        JwtAuthenticationResponse response = authService.refreshToken(request.getRefreshToken());
        return ResponseEntity.ok(response);
    }

    @PostMapping("/logout")
    @Operation(summary = "Logout user", description = "Logs the user out and invalidates the session.")
    public ResponseEntity<String> logoutUser(@Valid @RequestBody LogoutRequest logoutRequest) {
        authService.logoutUser(logoutRequest);
        return ResponseEntity.ok("User logged out successfully.");
    }

    @PostMapping("/password-reset")
    @Operation(summary = "Initiate password reset", description = "Sends password reset instructions to the user's email.")
    public ResponseEntity<String> initiatePasswordReset(@Valid @RequestBody PasswordResetRequest passwordResetRequest) {
        authService.initiatePasswordReset(passwordResetRequest);
        return ResponseEntity.ok("Password reset instructions have been sent to your email.");
    }

    @PostMapping("/verify-email")
    @Operation(summary = "Verify email", description = "Verifies the user's email using the provided token.")
    public ResponseEntity<String> verifyEmail(@RequestParam("token") String token) {
        try {
            authService.verifyEmail(token);
            return ResponseEntity.ok("Email verified successfully.");
        } catch (InvalidTokenException e) {
            return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body("Invalid or expired token.");
        }
    }

    @PostMapping("/change-password")
    @Operation(summary = "Change password", description = "Allows the user to change their password.")
    public ResponseEntity<String> changePassword(@Valid @RequestBody PasswordChangeRequest passwordChangeRequest) {
        authService.changePassword(passwordChangeRequest);
        return ResponseEntity.ok("Password changed successfully.");
    }

    @PostMapping("/verify-mfa")
    @Operation(summary = "Verify MFA code", description = "Verifies the MFA code for the user.")
    public ResponseEntity<String> verifyMfa(@Valid @RequestBody MfaVerificationRequest mfaRequest) {
        User user = userRepository.findByEmail(mfaRequest.getEmail())
                .orElseThrow(() -> new UsernameNotFoundException("User not found with email: " + mfaRequest.getEmail()));

        boolean isVerified = mfaTokenService.verifyMfaCode(mfaRequest.getMfaCode(), user);
        if (!isVerified) {
            throw new BadCredentialsException("Invalid or expired MFA code");
        }

        auditLogService.logAction(user, "MFA_VERIFIED", getClientIp(), "MFA code verified successfully");

        return ResponseEntity.ok("MFA verified successfully");
    }

    @GetMapping("/user-profile")
    @Operation(summary = "Get user profile", description = "Retrieves the profile details of the user.")
    public ResponseEntity<UserProfileResponse> getUserProfile(@RequestParam String username) {
        UserProfileResponse profile = authService.getUserProfile(username);
        return ResponseEntity.ok(profile);
    }

    private String getClientIp() {
        ServletRequestAttributes attrs = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();
        if (attrs == null) return "UNKNOWN_IP";
        HttpServletRequest request = attrs.getRequest();
        String ipAddress = request.getHeader("X-Forwarded-For");
        if (ipAddress == null || ipAddress.isBlank() || "unknown".equalsIgnoreCase(ipAddress)) {
            ipAddress = request.getRemoteAddr();
        }
        return ipAddress;
    }
}


==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/CTIMySQLFINAL/src/main/java/orsk/compli/controller/webScraper/AdvancedWebScrapingController.java
==============================
package orsk.compli.controller.webScraper;

import io.jsonwebtoken.io.IOException;
import org.jsoup.Jsoup;
import org.jsoup.nodes.Document;
import org.jsoup.select.Elements;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping("/api/scrape")
public class AdvancedWebScrapingController {

    private static final Logger logger = LoggerFactory.getLogger(AdvancedWebScrapingController.class);

    @GetMapping
    public ResponseEntity<?> scrapeWebsite(
            @RequestParam String url,
            @RequestParam(required = false) String elementSelector,
            @RequestParam(required = false, defaultValue = "false") boolean useProxy) {

        try {
            Document document;

            if (useProxy) {
                // Connect via a proxy
                document = Jsoup.connect(url)
                        .proxy("proxyHost", 8080) // Replace with actual proxy details
                        .get();
            } else {
                // Direct connection
                document = Jsoup.connect(url).get();
            }

            if (elementSelector != null && !elementSelector.isEmpty()) {
                Elements elements = document.select(elementSelector);
                return ResponseEntity.ok(elements.toString());
            }

            return ResponseEntity.ok(document.html());

        } catch (IOException e) {
            logger.error("Error scraping the website: {}", e.getMessage());
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                    .body("Failed to scrape the website. Error: " + e.getMessage());
        } catch (java.io.IOException e) {
            throw new RuntimeException(e);
        }
    }
}


==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/CTIMySQLFINAL/src/main/java/orsk/compli/controller/jpa/VulnerabilityControllerJpaJpa.java
==============================
package orsk.compli.controller.jpa;

import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;
import orsk.compli.dtos.jpa.VulnerabilityDTO;
import orsk.compli.entities.Vulnerability;
import orsk.compli.service.jpa.VulnerabilityJpaService;
import orsk.compli.service.jpa.CrudService;

@RestController("jpaVulnerabilityController")
@RequestMapping("/api/mysql/vulnerabilities")
public class VulnerabilityControllerJpaJpa extends AbstractCrudControllerJpa<Vulnerability, Long> {

    private final VulnerabilityJpaService vulnerabilityService;

    public VulnerabilityControllerJpaJpa(VulnerabilityJpaService vulnerabilityService) {
        this.vulnerabilityService = vulnerabilityService;
    }

    @Override
    protected CrudService<Vulnerability, Long> getService() {
        return vulnerabilityService;
    }
}



==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/CTIMySQLFINAL/src/main/java/orsk/compli/controller/jpa/ProtectedResourceController.java
==============================
/*
package orsk.compli.controller.jpa;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestHeader;
import org.springframework.web.bind.annotation.RestController;
import orsk.compli.util.TokenValidator;

@RestController
public class ProtectedResourceController {

    @Autowired
    private TokenValidator tokenValidator;

    @GetMapping("/protected-resource")
    public ResponseEntity<String> accessProtectedResource(@RequestHeader("Authorization") String token) {
        // Strip "Bearer " prefix if present
        if (token.startsWith("Bearer ")) {
            token = token.substring(7);
        }

        boolean isValid = tokenValidator.isValidToken(token);

        if (isValid) {
            return ResponseEntity.ok("Access granted to protected resource");
        } else {
            return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body("Invalid or expired token");
        }
    }
}
*/



==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/CTIMySQLFINAL/src/main/java/orsk/compli/controller/jpa/ThreatActorControllerJpaJpa.java
==============================
package orsk.compli.controller.jpa;

import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import orsk.compli.dtos.jpa.ThreatActorDTO;
import orsk.compli.entities.ThreatActor;
import orsk.compli.service.jpa.ThreatActorJpaService;
import orsk.compli.service.jpa.CrudService;

@RestController("jpaThreatActorController")
@RequestMapping("/api/mysql/threat-actors")
public class ThreatActorControllerJpaJpa extends AbstractCrudControllerJpa<ThreatActor, Long> {

    private final ThreatActorJpaService threatActorService;

    public ThreatActorControllerJpaJpa(ThreatActorJpaService threatActorService) {
        this.threatActorService = threatActorService;
    }

    /**
     * Fetch a single ThreatActor as DTO by ID with all relevant details eagerly initialized.
     */


    @Override
    protected CrudService<ThreatActor, Long> getService() {
        return threatActorService;
    }
}


==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/CTIMySQLFINAL/src/main/java/orsk/compli/controller/jpa/ThreatActorTypeControllerJpaJpa.java
==============================
package orsk.compli.controller.jpa;

import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;
import orsk.compli.entities.ThreatActorType;
import orsk.compli.service.jpa.ThreatActorTypeJpaService;
import orsk.compli.service.jpa.CrudService;

@RestController("jpaThreatActorTypeController")
@RequestMapping("/api/mysql/threat-actor-types")
public class ThreatActorTypeControllerJpaJpa extends AbstractCrudControllerJpa<ThreatActorType, Long> {

    private final ThreatActorTypeJpaService threatActorTypeService;

    public ThreatActorTypeControllerJpaJpa(ThreatActorTypeJpaService threatActorTypeService) {
        this.threatActorTypeService = threatActorTypeService;
    }

    @Override
    protected CrudService<ThreatActorType, Long> getService() {
        return threatActorTypeService;
    }
}



==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/CTIMySQLFINAL/src/main/java/orsk/compli/controller/jpa/AbstractCrudControllerJpa.java
==============================
package orsk.compli.controller.jpa;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.dao.DataAccessException;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.server.ResponseStatusException;
import orsk.compli.service.jpa.CrudService;

import java.util.List;

/**
 * Abstract CRUD controller providing standard endpoints.
 */
public abstract class AbstractCrudControllerJpa<T, ID> {

    private static final Logger logger = LoggerFactory.getLogger(AbstractCrudControllerJpa.class);

    protected abstract CrudService<T, ID> getService();

    @PreAuthorize("hasAuthority('ROLE_ADMIN')")
    @PostMapping
    public ResponseEntity<T> create(@RequestBody T dto) {
        try {
            T created = getService().create(dto);
            return ResponseEntity.status(HttpStatus.CREATED).body(created);
        } catch (DataAccessException e) {
            logger.error("Error creating entity: {}", e.getMessage());
            throw new ResponseStatusException(HttpStatus.INTERNAL_SERVER_ERROR, "Error creating entity");
        }
    }

    @PreAuthorize("hasAuthority('ROLE_ADMIN')")
    @PostMapping("/batch")
    public ResponseEntity<List<T>> createBatch(@RequestBody List<T> dtos) {
        try {
            List<T> createdEntities = getService().createAll(dtos);
            return ResponseEntity.status(HttpStatus.CREATED).body(createdEntities);
        } catch (DataAccessException e) {
            logger.error("Error creating batch of entities: {}", e.getMessage());
            throw new ResponseStatusException(HttpStatus.INTERNAL_SERVER_ERROR, "Error creating batch of entities");
        }
    }

    @PreAuthorize("hasAnyAuthority('ROLE_USER','ROLE_ADMIN')")
    @GetMapping
    public ResponseEntity<List<T>> getAll() {
        try {
            List<T> dtos = getService().getAll();
            if (dtos.isEmpty()) {
                return ResponseEntity.noContent().build();
            }
            return ResponseEntity.ok(dtos);
        } catch (DataAccessException e) {
            logger.error("Error retrieving entities: {}", e.getMessage());
            throw new ResponseStatusException(HttpStatus.INTERNAL_SERVER_ERROR, "Error retrieving entities");
        }
    }

    @PreAuthorize("hasAnyAuthority('ROLE_USER','ROLE_ADMIN')")
    @GetMapping("/{id}")
    public ResponseEntity<T> getById(@PathVariable ID id) {
        try {
            return getService().getById(id)
                    .map(ResponseEntity::ok)
                    .orElse(ResponseEntity.notFound().build());
        } catch (DataAccessException e) {
            logger.error("Error retrieving entity by ID {}: {}", id, e.getMessage());
            throw new ResponseStatusException(HttpStatus.INTERNAL_SERVER_ERROR, "Error retrieving entity by ID");
        }
    }

    @PreAuthorize("hasAuthority('ROLE_ADMIN')")
    @PutMapping("/{id}")
    public ResponseEntity<T> update(@PathVariable ID id, @RequestBody T dto) {
        try {
            T updated = getService().update(id, dto);
            return ResponseEntity.ok(updated);
        } catch (DataAccessException e) {
            logger.error("Error updating entity with ID {}: {}", id, e.getMessage());
            throw new ResponseStatusException(HttpStatus.INTERNAL_SERVER_ERROR, "Error updating entity");
        }
    }

    @PreAuthorize("hasAuthority('ROLE_ADMIN')")
    @DeleteMapping("/{id}")
    public ResponseEntity<Void> delete(@PathVariable ID id) {
        try {
            boolean deleted = getService().delete(id);
            return deleted ? ResponseEntity.noContent().build() : ResponseEntity.notFound().build();
        } catch (DataAccessException e) {
            logger.error("Error deleting entity with ID {}: {}", id, e.getMessage());
            throw new ResponseStatusException(HttpStatus.INTERNAL_SERVER_ERROR, "Error deleting entity");
        }
    }
}


==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/CTIMySQLFINAL/src/main/java/orsk/compli/controller/jpa/SearchController.java
==============================
package orsk.compli.controller.jpa;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;
import orsk.compli.dtos.auth.SearchOptionsResponse;
import orsk.compli.service.jpa.SearchService;

import java.util.List;

/**
 * Controller to provide search options or metadata for building advanced queries.
 */
@RestController("jpaSearchController")
@RequestMapping("/api/mysql")
public class SearchController {

    private final SearchService searchService;

    @Autowired
    public SearchController(SearchService searchService) {
        this.searchService = searchService;
    }

    @GetMapping("/search-options")
    public SearchOptionsResponse getSearchOptions() {
        List<String> products = searchService.getAffectedProductNames();
        List<String> countries = searchService.getCountryNames();
        List<String> threats = searchService.getGlobalThreatNames();
        // Add more categories as needed

        return new SearchOptionsResponse(products, countries, threats);
    }
}



==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/CTIMySQLFINAL/src/main/java/orsk/compli/controller/jpa/ConsumerController.java
==============================
/*
package orsk.compli.controller.jpa;

import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import orsk.compli.dtos.JwtAuthenticationResponse;
import orsk.compli.dtos.LoginRequest;
import orsk.compli.service.jpa.AuthClientService;

@RestController
@RequestMapping("/api/consumer")
@RequiredArgsConstructor
public class ConsumerController {

    private final AuthClientService authClientService;

    @PostMapping("/login")
    public ResponseEntity<JwtAuthenticationResponse> login(@RequestBody LoginRequest loginRequest) {
        JwtAuthenticationResponse response = authClientService.login(loginRequest);
        return ResponseEntity.ok(response);
    }

    @PostMapping("/refresh-token")
    public ResponseEntity<JwtAuthenticationResponse> refreshToken(@RequestBody String refreshToken) {
        JwtAuthenticationResponse response = authClientService.refreshToken(refreshToken);
        return ResponseEntity.ok(response);
    }

    @PostMapping("/logout")
    public ResponseEntity<String> logout(@RequestBody String token) {
        authClientService.logout(token);
        return ResponseEntity.ok("Logged out successfully");
    }
}
*/



==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/CTIMySQLFINAL/src/main/java/orsk/compli/controller/jpa/GeolocationControllerJpaJpa.java
==============================
package orsk.compli.controller.jpa;

import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;
import orsk.compli.entities.Country; // Example if you had a separate Geolocation
import orsk.compli.entities.Geolocation;
import orsk.compli.entities.Geolocation;
import orsk.compli.service.jpa.GeolocationJpaService;
import orsk.compli.service.jpa.CrudService;

/**
 * Example Geolocation controller.
 * Replace 'Country' with your actual 'Geolocation' if you have one.
 */
@RestController("jpaGeolocationController")
@RequestMapping("/api/mysql/geolocations")
public class GeolocationControllerJpaJpa extends AbstractCrudControllerJpa<Geolocation, Long> {

    private final GeolocationJpaService geolocationService;

    public GeolocationControllerJpaJpa(GeolocationJpaService geolocationService) {
        this.geolocationService = geolocationService;
    }

    @Override
    protected CrudService<Geolocation, Long> getService() {
        return geolocationService;
    }
}



==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/CTIMySQLFINAL/src/main/java/orsk/compli/controller/jpa/GlobalThreatControllerJpaJpa.java
==============================
package orsk.compli.controller.jpa;

import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;
import orsk.compli.dtos.jpa.GlobalThreatDTO;
import orsk.compli.entities.GlobalThreat;
import orsk.compli.service.jpa.GlobalThreatJpaService;
import orsk.compli.service.jpa.CrudService;

@RestController("jpaGlobalThreatController")
@RequestMapping("/api/mysql/global-threats")
public class GlobalThreatControllerJpaJpa extends AbstractCrudControllerJpa<GlobalThreat, Long> {

    private final GlobalThreatJpaService globalThreatService;

    public GlobalThreatControllerJpaJpa(GlobalThreatJpaService globalThreatService) {
        this.globalThreatService = globalThreatService;
    }

    @Override
    protected CrudService<GlobalThreat, Long> getService() {
        return globalThreatService;
    }
}



==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/CTIMySQLFINAL/src/main/java/orsk/compli/controller/jpa/AttackVectorCategoryControllerJpaJpa.java
==============================
package orsk.compli.controller.jpa;

import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;
import orsk.compli.entities.AttackVectorCategory;
import orsk.compli.service.jpa.AttackVectorCategoryJpaService;
import orsk.compli.service.jpa.CrudService;

/**
 * Example AttackVectorCategory controller.
 * Replace AttackVectorDTO with AttackVectorCategoryDTO if you have a dedicated one.
 */
@RestController("jpaAttackVectorCategoryController")
@RequestMapping("/api/mysql/attack-vector-categorys")
public class AttackVectorCategoryControllerJpaJpa extends AbstractCrudControllerJpa<AttackVectorCategory, Long> {

    private final AttackVectorCategoryJpaService attackVectorCategoryService;

    public AttackVectorCategoryControllerJpaJpa(AttackVectorCategoryJpaService attackVectorCategoryService) {
        this.attackVectorCategoryService = attackVectorCategoryService;
    }

    @Override
    protected CrudService<AttackVectorCategory, Long> getService() {
        return attackVectorCategoryService;
    }
}



==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/CTIMySQLFINAL/src/main/java/orsk/compli/controller/jpa/CountryControllerJpaJpa.java
==============================
package orsk.compli.controller.jpa;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.dao.DataAccessException;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.server.ResponseStatusException;
import orsk.compli.dtos.jpa.CountryDTO;
import orsk.compli.entities.Country;
import orsk.compli.service.jpa.CountryJpaService;
import orsk.compli.service.jpa.CrudService;

import java.util.List;

/**
 * Example Country controller that uses CountryDTO for data transfer.
 */
@RestController("jpaCountryController")
@RequestMapping("/api/mysql/countries")
public class CountryControllerJpaJpa extends AbstractCrudControllerJpa<Country, Long> {

    private static final Logger logger = LoggerFactory.getLogger(CountryControllerJpaJpa.class);
    private final CountryJpaService countryService;

    public CountryControllerJpaJpa(CountryJpaService countryService) {
        this.countryService = countryService;
    }

    @Override
    protected CrudService<Country, Long> getService() {
        return countryService;
    }

    /**
     * Batch create endpoint specifically for CountryDTO.
     *
     * @param countries List of CountryDTO
     * @return List of created CountryDTO
     */
    @PostMapping("/batch")
    public ResponseEntity<List<Country>> createBatch(@RequestBody List<Country> countries) {
        try {
            List<Country> createdCountries = countryService.createAll(countries);
            return ResponseEntity.status(HttpStatus.CREATED).body(createdCountries);
        } catch (DataAccessException e) {
            logger.error("Error creating countries: {}", e.getMessage());
            throw new ResponseStatusException(HttpStatus.INTERNAL_SERVER_ERROR, "Error creating countries");
        }
    }
}



==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/CTIMySQLFINAL/src/main/java/orsk/compli/controller/jpa/AttackVectorControllerJpaJpa.java
==============================
package orsk.compli.controller.jpa;

import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;
import orsk.compli.dtos.jpa.AttackVectorDTO;
import orsk.compli.entities.AttackVector;
import orsk.compli.service.jpa.AttackVectorJpaService;
import orsk.compli.service.jpa.CrudService;

@RestController("jpaAttackVectorController")
@RequestMapping("/api/mysql/attack-vectors")
public class AttackVectorControllerJpaJpa extends AbstractCrudControllerJpa<AttackVector, Long> {

    private final AttackVectorJpaService attackVectorService;

    public AttackVectorControllerJpaJpa(AttackVectorJpaService attackVectorService) {
        this.attackVectorService = attackVectorService;
    }

    @Override
    protected CrudService<AttackVector, Long> getService() {
        return attackVectorService;
    }
}



==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/CTIMySQLFINAL/src/main/java/orsk/compli/controller/jpa/AffectedProductControllerJpaJpa.java
==============================
package orsk.compli.controller.jpa;

import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;
import orsk.compli.entities.AffectedProduct;
import orsk.compli.service.jpa.AffectedProductJpaService;
import orsk.compli.service.jpa.CrudService;

/**
 * Example AffectedProduct controller that uses AffectedProductDTO.
 */
@RestController("jpaAffectedProductController")
@RequestMapping("/api/mysql/affected-products")
public class AffectedProductControllerJpaJpa extends AbstractCrudControllerJpa<AffectedProduct, Long> {

    private final AffectedProductJpaService affectedProductService;

    public AffectedProductControllerJpaJpa(AffectedProductJpaService affectedProductService) {
        this.affectedProductService = affectedProductService;
    }

    @Override
    protected CrudService<AffectedProduct, Long> getService() {
        return affectedProductService;
    }
}



==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/CTIMySQLFINAL/src/main/java/orsk/compli/controller/jpa/ThreatCategoryControllerJpaJpa.java
==============================
package orsk.compli.controller.jpa;

import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;
import orsk.compli.dtos.jpa.ThreatCategoryDTO;
import orsk.compli.entities.ThreatCategory;
import orsk.compli.service.jpa.ThreatCategoryJpaService;
import orsk.compli.service.jpa.CrudService;

@RestController("jpaThreatCategoryController")
@RequestMapping("/api/mysql/threat-categorys")
public class ThreatCategoryControllerJpaJpa extends AbstractCrudControllerJpa<ThreatCategory, Long> {

    private final ThreatCategoryJpaService threatCategoryService;

    public ThreatCategoryControllerJpaJpa(ThreatCategoryJpaService threatCategoryService) {
        this.threatCategoryService = threatCategoryService;
    }

    @Override
    protected CrudService<ThreatCategory, Long> getService() {
        return threatCategoryService;
    }
}



==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/CTIMySQLFINAL/src/main/java/orsk/compli/dtos/auth/MfaVerificationRequest.java
==============================
package orsk.compli.dtos.auth;

import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import lombok.Builder;
import lombok.Data;

@Data
@Builder
public class MfaVerificationRequest {
    @NotBlank(message = "MFA code is required")
    private String mfaCode;

    @Email(message = "Invalid email address")
    @NotBlank(message = "Email address is required")
    private String email;
}


==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/CTIMySQLFINAL/src/main/java/orsk/compli/dtos/auth/UserProfileResponse.java
==============================
package orsk.compli.dtos.auth;

import java.util.List;

public class UserProfileResponse {
    private String username;
    private String email;
    private List<String> roles;
    private boolean enabled;

    public UserProfileResponse(String username, String email, List<String> roles, boolean enabled) {
        this.username = username;
        this.email = email;
        this.roles = roles;
        this.enabled = enabled;
    }

    // Getters and Setters
}


==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/CTIMySQLFINAL/src/main/java/orsk/compli/dtos/auth/RegistrationRequest.java
==============================
package orsk.compli.dtos.auth;

import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Pattern;
import jakarta.validation.constraints.Size;
import lombok.*;

@Getter
@Setter
@Builder
@Data
@NoArgsConstructor
@AllArgsConstructor
public class RegistrationRequest {

    @NotBlank(message = "Username is required")
    @Size(min = 3, max = 50, message = "Username must be between 3 and 50 characters")
    private String username;

    @NotBlank(message = "Password is required")
    @Size(min = 12, message = "Password must be at least 12 characters")
    @Pattern(regexp = "^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)(?=.*[@$!%*?&#^()_+{}|:;<>,.?/~`-]).+$",
            message = "Password must contain at least one uppercase letter, one lowercase letter, one number, and one special character")
    private String password;

    @NotBlank(message = "Email is required")
    @Email(message = "Email should be valid")
    private String email;

    private Boolean consentToDataUsage = false;
}


==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/CTIMySQLFINAL/src/main/java/orsk/compli/dtos/auth/LogoutRequest.java
==============================
package orsk.compli.dtos.auth;

import jakarta.validation.constraints.NotBlank;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
@AllArgsConstructor
public class LogoutRequest {

    @NotBlank(message = "Refresh token is required")
    private String refreshToken;


}



==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/CTIMySQLFINAL/src/main/java/orsk/compli/dtos/auth/TokenRefreshRequest.java
==============================
package orsk.compli.dtos.auth;

import jakarta.validation.constraints.NotBlank;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
@AllArgsConstructor
public class TokenRefreshRequest {

    @NotBlank(message = "Refresh token is required")
    private String refreshToken;
}


==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/CTIMySQLFINAL/src/main/java/orsk/compli/dtos/auth/LoginRequest.java
==============================
package orsk.compli.dtos.auth;

import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

/**
 * DTO for user login requests.
 */
@Data
@Builder
@AllArgsConstructor
@NoArgsConstructor
public class LoginRequest {

    @NotBlank(message = "Email is required")
    @Email(message = "Invalid email format")
    String email;

    @NotBlank(message = "Password is required")
    String password;
}


==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/CTIMySQLFINAL/src/main/java/orsk/compli/dtos/auth/PasswordResetRequest.java
==============================
package orsk.compli.dtos.auth;

import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
public class PasswordResetRequest {

    @NotBlank(message = "Email is required")
    @Email(message = "Email should be valid")
    private String email;
}


==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/CTIMySQLFINAL/src/main/java/orsk/compli/dtos/auth/UserDTO.java
==============================
package orsk.compli.dtos.auth;

public class UserDTO {
    private Long id;
    private String username;
    private String email;
    private String role;
    private boolean enabled;

    // Getters and Setters
}


==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/CTIMySQLFINAL/src/main/java/orsk/compli/dtos/auth/JwtAuthenticationResponse.java
==============================
package orsk.compli.dtos.auth;

import lombok.Builder;
import lombok.Data;
import lombok.Value;

/**
 * Response containing tokens and optional message after authentication.
 */
@Value
@Builder
@Data
public class JwtAuthenticationResponse {
    String accessToken;
    String refreshToken;
    @Builder.Default
    String tokenType = "Bearer";
    String message;
    
    // Example static factory methods for clarity
    public static JwtAuthenticationResponse ofTokens(String accessToken, String refreshToken) {
        return JwtAuthenticationResponse.builder()
                .accessToken(accessToken)
                .refreshToken(refreshToken)
                .message(null)
                .build();
    }

    public static JwtAuthenticationResponse ofMessage(String message) {
        return null;
    }

    public void setAccessToken(String s) {
    }
}


==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/CTIMySQLFINAL/src/main/java/orsk/compli/dtos/auth/PasswordChangeRequest.java
==============================
package orsk.compli.dtos.auth;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Pattern;
import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
public class PasswordChangeRequest {

    @NotBlank(message = "Reset token is required")
    private String token;

    @NotBlank(message = "New password is required")
    @Pattern(regexp = "^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)(?=.*[@$!%*?&#^()_+{}|:;<>,.?/~`-]).+$",
            message = "Password must contain at least one uppercase letter, one lowercase letter, one number, and one special character")
    private String newPassword;
}


==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/CTIMySQLFINAL/src/main/java/orsk/compli/dtos/auth/SearchOptionsResponse.java
==============================
// File: src/main/java/orsk/compli/dtos/SearchOptionsResponse.java

package orsk.compli.dtos.auth;

import lombok.AllArgsConstructor;
import lombok.Data;

import java.util.List;

@Data
@AllArgsConstructor
public class SearchOptionsResponse {
    private List<String> products;
    private List<String> countries;
    private List<String> threats;
    // Add more fields as needed
}


==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/CTIMySQLFINAL/src/main/java/orsk/compli/dtos/jpa/AuditLogDTO.java
==============================
package orsk.compli.dtos.jpa;

import lombok.Data;
import java.time.Instant;

@Data
public class AuditLogDTO {
    private Long id;
    private String action;
    private String ipAddress;
    private Instant timestamp;
    private String details;
}




==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/CTIMySQLFINAL/src/main/java/orsk/compli/dtos/jpa/ThreatPredictionDTO.java
==============================
package orsk.compli.dtos.jpa;

import lombok.Data;
import java.time.LocalDate;

@Data
public class ThreatPredictionDTO {
    private Long id;
    private LocalDate predictionDate;
    private String predictedImpact;
    private Double probability;
}




==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/CTIMySQLFINAL/src/main/java/orsk/compli/dtos/jpa/CountryDTO.java
==============================
package orsk.compli.dtos.jpa;

import lombok.Data;

@Data
public class CountryDTO {
    private String countryCode;
    private String countryName;
}




==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/CTIMySQLFINAL/src/main/java/orsk/compli/dtos/jpa/VulnerabilityProductAssociationDTO.java
==============================
package orsk.compli.dtos.jpa;

import lombok.Data;

@Data
public class VulnerabilityProductAssociationDTO {
    private Integer vulnerabilityId;
    private Integer productId;
}




==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/CTIMySQLFINAL/src/main/java/orsk/compli/dtos/jpa/MachineLearningFeatureDTO.java
==============================
package orsk.compli.dtos.jpa;

import lombok.Data;
import java.time.Instant;
import java.util.Map;

@Data
public class MachineLearningFeatureDTO {
    private Long id;
    private Long incidentId;
    private Map<String, Object> featureVector;
    private String featureName;
    private Double featureValue;
    private Instant createdAt;
}




==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/CTIMySQLFINAL/src/main/java/orsk/compli/dtos/jpa/VulnerabilityDTO.java
==============================
package orsk.compli.dtos.jpa;

import lombok.Data;

@Data
public class VulnerabilityDTO {
    private Integer id;
    private String cveId;
    private String name;
    private int severity;
}




==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/CTIMySQLFINAL/src/main/java/orsk/compli/dtos/jpa/ThreatActorDTO.java
==============================
package orsk.compli.dtos.jpa;

import lombok.Data;

import java.time.Instant;
import java.time.LocalDate;
import java.util.List;

/**
 * Data Transfer Object for ThreatActor.
 */
@Data
public class ThreatActorDTO {
    private Integer id;
    private String actorName;
    private String motivation;
    private String capabilities;
    private String typeName; // Name of the ThreatActorType
    private String originCountryName; // Name of the Country
    private String categoryName; // Name of the ThreatCategory
    private LocalDate firstObserved;
    private LocalDate lastActivity;
    private Instant createdAt;
    private Instant updatedAt;
    private List<String> attackVectorNames; // List of associated AttackVector names
}


==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/CTIMySQLFINAL/src/main/java/orsk/compli/dtos/jpa/UserRoleDTO.java
==============================
package orsk.compli.dtos.jpa;

import lombok.Data;

@Data
public class UserRoleDTO {
    private Long id;
    private Long userId;
    private String role;
    private Long roleId;
}




==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/CTIMySQLFINAL/src/main/java/orsk/compli/dtos/jpa/RefreshTokenDTO.java
==============================
package orsk.compli.dtos.jpa;

import lombok.Data;
import java.time.Instant;

@Data
public class RefreshTokenDTO {
    private Long id;
    private String token;
    private Instant expiryDate;
    private Long userId;
}




==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/CTIMySQLFINAL/src/main/java/orsk/compli/dtos/jpa/ThreatCategoryDTO.java
==============================
package orsk.compli.dtos.jpa;

import lombok.Data;

@Data
public class ThreatCategoryDTO {
    private Integer id;
    private String categoryName;
    private String description;
}




==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/CTIMySQLFINAL/src/main/java/orsk/compli/dtos/jpa/DeviceDTO.java
==============================
package orsk.compli.dtos.jpa;

import lombok.Data;

import java.time.Instant;

@Data
public class DeviceDTO {
    private Long id;
    private String deviceId;
    private String deviceType;
    private Instant registeredAt;
}




==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/CTIMySQLFINAL/src/main/java/orsk/compli/dtos/jpa/TenantDTO.java
==============================
package orsk.compli.dtos.jpa;

import lombok.Data;

@Data
public class TenantDTO {
    private Long id;
    private String name;
}




==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/CTIMySQLFINAL/src/main/java/orsk/compli/dtos/jpa/RolesPrivilegeDTO.java
==============================
package orsk.compli.dtos.jpa;

import lombok.Data;

@Data
public class RolesPrivilegeDTO {
    private Long roleId;
    private Long privilegeId;
}




==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/CTIMySQLFINAL/src/main/java/orsk/compli/dtos/jpa/ThreatActorTypeDTO.java
==============================
package orsk.compli.dtos.jpa;

import lombok.Data;

@Data
public class ThreatActorTypeDTO {
    private Integer id;
    private String typeName;
    private String description;
}




==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/CTIMySQLFINAL/src/main/java/orsk/compli/dtos/jpa/TimeSeriesAnalyticDTO.java
==============================
package orsk.compli.dtos.jpa;

import lombok.Data;
import java.time.LocalDate;

@Data
public class TimeSeriesAnalyticDTO {
    private Long id;
    private LocalDate analysisDate;
    private String metric;
    private Double value;
}




==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/CTIMySQLFINAL/src/main/java/orsk/compli/dtos/jpa/AffectedProductDTO.java
==============================
package orsk.compli.dtos.jpa;

import lombok.Data;
import java.time.Instant;

@Data
public class AffectedProductDTO {
    private Integer id;
    private String productName;
    private String vendor;
    private String version;
    private Instant createdAt;
    private Instant updatedAt;
}




==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/CTIMySQLFINAL/src/main/java/orsk/compli/dtos/jpa/StatisticalReportDTO.java
==============================
package orsk.compli.dtos.jpa;

import lombok.Data;
import java.time.LocalDate;

@Data
public class StatisticalReportDTO {
    private Long id;
    private String content;
    private LocalDate generatedDate;
    private String reportType;
}




==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/CTIMySQLFINAL/src/main/java/orsk/compli/dtos/jpa/IncidentLogDTO.java
==============================
package orsk.compli.dtos.jpa;

import lombok.Data;
import java.time.Instant;

@Data
public class IncidentLogDTO {
    private Long id;
    private String target;
    private Instant incidentDate;
    private String impact;
    private String response;
    private Instant responseDate;
}




==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/CTIMySQLFINAL/src/main/java/orsk/compli/dtos/jpa/VerificationTokenDTO.java
==============================
package orsk.compli.dtos.jpa;

import lombok.Data;
import java.time.Instant;

@Data
public class VerificationTokenDTO {
    private Long id;
    private String token;
    private Instant expiryDate;
}




==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/CTIMySQLFINAL/src/main/java/orsk/compli/dtos/jpa/GeolocationDTO.java
==============================
package orsk.compli.dtos.jpa;

import lombok.Data;

import java.math.BigDecimal;
import java.time.Instant;

@Data
public class GeolocationDTO {
    private Long id;
    private String ipAddress;
    private Long countryId; // Assuming Country has an ID
    private String countryName; // Optional, if you want to include more details about the country
    private String region;
    private String city;
    private BigDecimal latitude;
    private BigDecimal longitude;
    private Instant createdAt;
    private Instant updatedAt;
}


==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/CTIMySQLFINAL/src/main/java/orsk/compli/dtos/jpa/RoleDTO.java
==============================
package orsk.compli.dtos.jpa;

import lombok.Data;

@Data
public class RoleDTO {
    private Long id;
    private String name;
}




==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/CTIMySQLFINAL/src/main/java/orsk/compli/dtos/jpa/GlobalThreatDTO.java
==============================
package orsk.compli.dtos.jpa;

import lombok.Data;
import java.time.LocalDate;

@Data
public class GlobalThreatDTO {
    private Integer id;
    private String name;
    private String description;
    private LocalDate firstDetected;
    private LocalDate lastUpdated;
    private Integer severityLevel;
}




==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/CTIMySQLFINAL/src/main/java/orsk/compli/dtos/jpa/FailedLoginDTO.java
==============================
package orsk.compli.dtos.jpa;

import lombok.Data;
import java.time.Instant;

@Data
public class FailedLoginDTO {
    private Long id;
    private String username;
    private String ipAddress;
    private Instant attemptTime;
    private String reason;
}




==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/CTIMySQLFINAL/src/main/java/orsk/compli/dtos/jpa/MfaTokenDTO.java
==============================
package orsk.compli.dtos.jpa;

import lombok.Data;
import java.time.LocalDateTime;

@Data
public class MfaTokenDTO {
    private Long id;
    private String mfaCode;
    private LocalDateTime expiryDate;
    private Boolean used;
}




==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/CTIMySQLFINAL/src/main/java/orsk/compli/dtos/jpa/PrivilegeDTO.java
==============================
package orsk.compli.dtos.jpa;

import lombok.Data;

@Data
public class PrivilegeDTO {
    private Long id;
    private String name;
}




==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/CTIMySQLFINAL/src/main/java/orsk/compli/dtos/jpa/AttackVectorDTO.java
==============================
package orsk.compli.dtos.jpa;

import lombok.Data;

import java.time.Instant;

/**
 * Data Transfer Object for AttackVector.
 */
@Data
public class AttackVectorDTO {
    private Integer id; // Unique identifier for the attack vector
    private String vectorName; // Name of the attack vector
    private String description; // Description of the attack vector
    private String categoryName; // Category name associated with the attack vector
    private Integer severityLevel; // Severity level of the attack vector
    private Instant createdAt; // Timestamp of creation
    private Instant updatedAt; // Timestamp of last update
}


==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/CTIMySQLFINAL/src/main/java/orsk/compli/model/Notification.java
==============================
package orsk.compli.model;

import lombok.Getter;
import lombok.Setter;

@Setter
@Getter

public class Notification {

    private String message;

    public Notification() {
    }

    public Notification(String message) {
        this.message = message;
    }

}



==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/CTIMySQLFINAL/src/main/java/orsk/compli/mappers/Mapper.java
==============================
package orsk.compli.mappers;

public interface Mapper<S, T> {

    /**
     * Maps the source object to the target object type.
     *
     * @param source The source object.
     * @return The mapped target object.
     */
    T map(S source);

    /**
     * Maps the target object to the source object type.
     *
     * @param target The target object.
     * @return The mapped source object.
     */
    S reverseMap(T target);
}


==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/CTIMySQLFINAL/src/main/java/orsk/compli/mappers/VulnerabilityMapper.java
==============================
package orsk.compli.mappers;

import orsk.compli.entities.Vulnerability;
import orsk.compli.dtos.jpa.VulnerabilityDTO;
import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.factory.Mappers;

/**
 * MapStruct Mapper for Vulnerability and VulnerabilityDTO.
 * Provides methods to map between Entity and DTO.
 */
@Mapper(componentModel = "spring")
public interface VulnerabilityMapper {

    VulnerabilityMapper INSTANCE = Mappers.getMapper(VulnerabilityMapper.class);

    /**
     * Converts Vulnerability entity to VulnerabilityDTO DTO.
     *
     * @param entity The Vulnerability entity.
     * @return The corresponding VulnerabilityDTO DTO.
     */
    VulnerabilityDTO toDto(Vulnerability entity);

    /**
     * Converts VulnerabilityDTO DTO to Vulnerability entity.
     *
     * @param dto The VulnerabilityDTO DTO.
     * @return The corresponding Vulnerability entity.
     */
    Vulnerability toEntity(VulnerabilityDTO dto);

    // Add custom field mappings if required
    // Example: @Mapping(source = "entityField", target = "dtoField")
}



==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/CTIMySQLFINAL/src/main/java/orsk/compli/mappers/GlobalThreatMapper.java
==============================
package orsk.compli.mappers;

import orsk.compli.entities.GlobalThreat;
import orsk.compli.dtos.jpa.GlobalThreatDTO;
import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.factory.Mappers;

/**
 * MapStruct Mapper for GlobalThreat and GlobalThreatDTO.
 * Provides methods to map between Entity and DTO.
 */
@Mapper(componentModel = "spring")
public interface GlobalThreatMapper {

    GlobalThreatMapper INSTANCE = Mappers.getMapper(GlobalThreatMapper.class);

    /**
     * Converts GlobalThreat entity to GlobalThreatDTO DTO.
     *
     * @param entity The GlobalThreat entity.
     * @return The corresponding GlobalThreatDTO DTO.
     */
    GlobalThreatDTO toDto(GlobalThreat entity);

    /**
     * Converts GlobalThreatDTO DTO to GlobalThreat entity.
     *
     * @param dto The GlobalThreatDTO DTO.
     * @return The corresponding GlobalThreat entity.
     */
    GlobalThreat toEntity(GlobalThreatDTO dto);

    // Add custom field mappings if required
    // Example: @Mapping(source = "entityField", target = "dtoField")
}



==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/CTIMySQLFINAL/src/main/java/orsk/compli/mappers/ThreatCategoryMapper.java
==============================
package orsk.compli.mappers;

import orsk.compli.entities.ThreatCategory;
import orsk.compli.dtos.jpa.ThreatCategoryDTO;
import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.factory.Mappers;

/**
 * MapStruct Mapper for ThreatCategory and ThreatCategoryDTO.
 * Provides methods to map between Entity and DTO.
 */
@Mapper(componentModel = "spring")
public interface ThreatCategoryMapper {

    ThreatCategoryMapper INSTANCE = Mappers.getMapper(ThreatCategoryMapper.class);

    /**
     * Converts ThreatCategory entity to ThreatCategoryDTO DTO.
     *
     * @param entity The ThreatCategory entity.
     * @return The corresponding ThreatCategoryDTO DTO.
     */
    ThreatCategoryDTO toDto(ThreatCategory entity);

    /**
     * Converts ThreatCategoryDTO DTO to ThreatCategory entity.
     *
     * @param dto The ThreatCategoryDTO DTO.
     * @return The corresponding ThreatCategory entity.
     */
    ThreatCategory toEntity(ThreatCategoryDTO dto);

    // Add custom field mappings if required
    // Example: @Mapping(source = "entityField", target = "dtoField")
}



==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/CTIMySQLFINAL/src/main/java/orsk/compli/mappers/ThreatActorTypeMapper.java
==============================
package orsk.compli.mappers;

import orsk.compli.entities.ThreatActorType;
import orsk.compli.dtos.jpa.ThreatActorTypeDTO;
import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.factory.Mappers;

/**
 * MapStruct Mapper for ThreatActorType and ThreatActorTypeDTO.
 * Provides methods to map between Entity and DTO.
 */
@Mapper(componentModel = "spring")
public interface ThreatActorTypeMapper {

    ThreatActorTypeMapper INSTANCE = Mappers.getMapper(ThreatActorTypeMapper.class);

    /**
     * Converts ThreatActorType entity to ThreatActorTypeDTO DTO.
     *
     * @param entity The ThreatActorType entity.
     * @return The corresponding ThreatActorTypeDTO DTO.
     */
    ThreatActorTypeDTO toDto(ThreatActorType entity);

    /**
     * Converts ThreatActorTypeDTO DTO to ThreatActorType entity.
     *
     * @param dto The ThreatActorTypeDTO DTO.
     * @return The corresponding ThreatActorType entity.
     */
    ThreatActorType toEntity(ThreatActorTypeDTO dto);

    // Add custom field mappings if required
    // Example: @Mapping(source = "entityField", target = "dtoField")
}



==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/CTIMySQLFINAL/src/main/java/orsk/compli/mappers/AffectedProductMapper.java
==============================
package orsk.compli.mappers;

import orsk.compli.entities.AffectedProduct;
import orsk.compli.dtos.jpa.AffectedProductDTO;
import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.factory.Mappers;

/**
 * MapStruct Mapper for AffectedProduct and AffectedProductDTO.
 * Provides methods to map between Entity and DTO.
 */
@Mapper(componentModel = "spring")
public interface AffectedProductMapper {

    AffectedProductMapper INSTANCE = Mappers.getMapper(AffectedProductMapper.class);

    /**
     * Converts AffectedProduct entity to AffectedProductDTO DTO.
     *
     * @param entity The AffectedProduct entity.
     * @return The corresponding AffectedProductDTO DTO.
     */
    AffectedProductDTO toDto(AffectedProduct entity);

    /**
     * Converts AffectedProductDTO DTO to AffectedProduct entity.
     *
     * @param dto The AffectedProductDTO DTO.
     * @return The corresponding AffectedProduct entity.
     */
    AffectedProduct toEntity(AffectedProductDTO dto);

    // Add custom field mappings if required
    // Example: @Mapping(source = "entityField", target = "dtoField")
}



==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/CTIMySQLFINAL/src/main/java/orsk/compli/mappers/AttackVectorMapper.java
==============================
package orsk.compli.mappers;

import orsk.compli.entities.AttackVector;
import orsk.compli.dtos.jpa.AttackVectorDTO;
import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.factory.Mappers;

/**
 * MapStruct Mapper for AttackVector and AttackVectorDTO.
 * Provides methods to map between Entity and DTO.
 */
@Mapper(componentModel = "spring")
public interface AttackVectorMapper {

    AttackVectorMapper INSTANCE = Mappers.getMapper(AttackVectorMapper.class);

    /**
     * Converts AttackVector entity to AttackVectorDTO DTO.
     *
     * @param entity The AttackVector entity.
     * @return The corresponding AttackVectorDTO DTO.
     */
    AttackVectorDTO toDto(AttackVector entity);

    /**
     * Converts AttackVectorDTO DTO to AttackVector entity.
     *
     * @param dto The AttackVectorDTO DTO.
     * @return The corresponding AttackVector entity.
     */
    AttackVector toEntity(AttackVectorDTO dto);

    // Add custom field mappings if required
    // Example: @Mapping(source = "entityField", target = "dtoField")
}



==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/CTIMySQLFINAL/src/main/java/orsk/compli/mappers/CountryMapper.java
==============================
package orsk.compli.mappers;

import orsk.compli.entities.Country;
import orsk.compli.dtos.jpa.CountryDTO;
import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.factory.Mappers;

/**
 * MapStruct Mapper for Country and CountryDTO.
 * Provides methods to map between Entity and DTO.
 */
@Mapper(componentModel = "spring")
public interface CountryMapper {

    CountryMapper INSTANCE = Mappers.getMapper(CountryMapper.class);

    /**
     * Converts Country entity to CountryDTO DTO.
     *
     * @param entity The Country entity.
     * @return The corresponding CountryDTO DTO.
     */
    CountryDTO toDto(Country entity);

    /**
     * Converts CountryDTO DTO to Country entity.
     *
     * @param dto The CountryDTO DTO.
     * @return The corresponding Country entity.
     */
    Country toEntity(CountryDTO dto);

    // Add custom field mappings if required
    // Example: @Mapping(source = "entityField", target = "dtoField")
}



==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/CTIMySQLFINAL/src/main/java/orsk/compli/mappers/ThreatActorMapper.java
==============================
package orsk.compli.mappers;

import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import orsk.compli.dtos.jpa.ThreatActorDTO;
import orsk.compli.entities.AttackVector;
import orsk.compli.entities.ThreatActor;

import java.util.Collections;
import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;

@Mapper(componentModel = "spring")
public interface ThreatActorMapper {

    @Mapping(source = "type.typeName", target = "typeName")
    @Mapping(source = "originCountry.countryName", target = "originCountryName")
    @Mapping(source = "category.categoryName", target = "categoryName")
    @Mapping(source = "attackVectors", target = "attackVectorNames")
    ThreatActorDTO toDto(ThreatActor entity);

    default List<String> mapAttackVectors(Set<AttackVector> attackVectors) {
        if (attackVectors == null) {
            return Collections.emptyList();
        }
        return attackVectors.stream()
                .map(AttackVector::getVectorName)
                .collect(Collectors.toList());
    }
}


==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/CTIMySQLFINAL/src/main/java/orsk/compli/service/auth/AdminService.java
==============================
package orsk.compli.service.auth;

import jakarta.persistence.EntityNotFoundException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import orsk.compli.entities.Role;
import orsk.compli.entities.User;
import orsk.compli.repository.auth.RoleRepository;
import orsk.compli.repository.auth.UserRepository;


import javax.management.relation.RoleNotFoundException;
import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;

@Service
public class AdminService {

    private static final Logger LOGGER = LoggerFactory.getLogger(AdminService.class);

    @Autowired
    private UserRepository userRepository;

    @Autowired
    private RoleRepository roleRepository;

    /**
     * Enables a user account by userId.
     * Admin access required.
     */
    @Transactional
    @PreAuthorize("hasRole('ADMIN')")
    public void enableUser(Long userId) {
        LOGGER.info("Enabling user with ID: {}", userId);
        User user = userRepository.findById(userId)
                .orElseThrow(() -> new EntityNotFoundException("User not found with ID: " + userId));

        if (user.getEnabled()) {
            LOGGER.warn("Attempted to enable an already enabled user with ID: {}", userId);
            throw new IllegalStateException("User is already enabled");
        }

        user.setEnabled(true);
        userRepository.save(user);
        LOGGER.info("User with ID: {} successfully enabled", userId);
    }

    /**
     * Disables a user account by userId.
     * Admin access required.
     */
    @Transactional
    @PreAuthorize("hasRole('ADMIN')")
    public void disableUser(Long userId) {
        LOGGER.info("Disabling user with ID: {}", userId);
        User user = userRepository.findById(userId)
                .orElseThrow(() -> new EntityNotFoundException("User not found with ID: " + userId));

        if (!user.getEnabled()) {
            LOGGER.warn("Attempted to disable an already disabled user with ID: {}", userId);
            throw new IllegalStateException("User is already disabled");
        }

        user.setEnabled(false);
        userRepository.save(user);
        LOGGER.info("User with ID: {} successfully disabled", userId);
    }

    /**
     * Updates a user's roles by userId.
     * Admin access required.
     */
    @Transactional
    @PreAuthorize("hasRole('ADMIN')")
    public void updateUserRoles(Long userId, List<String> roles) {
        LOGGER.info("Updating roles for user with ID: {}", userId);
        User user = userRepository.findById(userId)
                .orElseThrow(() -> new EntityNotFoundException("User not found with ID: " + userId));

        Set<Role> newRoles = roles.stream()
                .map(roleName -> {
                    try {
                        return roleRepository.findByName(roleName)
                                .orElseThrow(() -> new RoleNotFoundException("Role not found: " + roleName));
                    } catch (RoleNotFoundException e) {
                        throw new RuntimeException(e);
                    }
                })
                .collect(Collectors.toSet());

        user.setRoles(newRoles);
        userRepository.save(user);
        LOGGER.info("Roles updated successfully for user with ID: {}", userId);
    }

    /**
     * Retrieves all users (Admin access only).
     */
    @Transactional(readOnly = true)
    @PreAuthorize("hasRole('ADMIN')")
    public List<User> getAllUsers() {
        LOGGER.info("Fetching all users");
        return userRepository.findAll();
    }

    /**
     * Deletes a user by userId (Admin access only).
     */
    @Transactional
    @PreAuthorize("hasRole('ADMIN')")
    public void deleteUser(Long userId) {
        LOGGER.info("Deleting user with ID: {}", userId);
        User user = userRepository.findById(userId)
                .orElseThrow(() -> new EntityNotFoundException("User not found with ID: " + userId));

        userRepository.delete(user);
        LOGGER.info("User with ID: {} deleted successfully", userId);
    }

    /**
     * Fetches roles of a user by userId (Admin access only).
     */
    @Transactional(readOnly = true)
    @PreAuthorize("hasRole('ADMIN')")
    public Set<String> getUserRoles(Long userId) {
        LOGGER.info("Fetching roles for user with ID: {}", userId);
        User user = userRepository.findById(userId)
                .orElseThrow(() -> new EntityNotFoundException("User not found with ID: " + userId));

        Set<String> roles = user.getRoles().stream()
                .map(Role::getName)
                .collect(Collectors.toSet());

        LOGGER.info("Roles for user with ID: {} fetched successfully", userId);
        return roles;
    }
}


==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/CTIMySQLFINAL/src/main/java/orsk/compli/service/auth/UserService.java
==============================
package orsk.compli.service.auth;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;
import orsk.compli.entities.Role;
import orsk.compli.repository.auth.RoleRepository;
import orsk.compli.repository.auth.UserRepository;
import orsk.compli.entities.User;


import java.util.Collections;

@Service("UserService")
public class UserService {

    @Autowired
    private UserRepository userRepository;

    @Autowired
    private RoleRepository roleRepository;

    @Autowired
    private PasswordEncoder passwordEncoder;

    public User registerNewUser(User user) {
        if (userRepository.findByUsername(user.getUsername()).isPresent()) {
            throw new RuntimeException("Username already exists");
        }
        user.setPassword(passwordEncoder.encode(user.getPassword()));
        user.setEnabled(false); // User needs to be enabled after registration or email verification
        Role userRole = roleRepository.findByName("ROLE_USER")
                .orElseThrow(() -> new RuntimeException("ROLE_USER not found"));
        user.setRoles(Collections.singleton(userRole));
        return userRepository.save(user);
    }
}



==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/CTIMySQLFINAL/src/main/java/orsk/compli/service/auth/MfaTokenService.java
==============================
package orsk.compli.service.auth;

import org.springframework.stereotype.Service;
import orsk.compli.entities.MfaToken;
import orsk.compli.repository.auth.MfaTokenRepository;
import orsk.compli.entities.User;


import java.time.LocalDateTime;
import java.util.Optional;
import java.util.Random;

@Service("MfaTokenService")
public class MfaTokenService {

    private final MfaTokenRepository mfaTokenRepository;

    public MfaTokenService(MfaTokenRepository mfaTokenRepository) {
        this.mfaTokenRepository = mfaTokenRepository;
    }

    public MfaToken generateMfaToken(User user) {
        // Reuse existing valid token if present
        Optional<MfaToken> existingToken = mfaTokenRepository.findByUserUsername(user.getUsername())
                .filter(token -> token.getExpiryDate().isAfter(LocalDateTime.now()) && !token.getUsed());

        if (existingToken.isPresent()) {
            return existingToken.get();
        }

        MfaToken mfaToken = new MfaToken();
        mfaToken.setMfaCode(generateRandomMfaCode());
        mfaToken.setExpiryDate(LocalDateTime.now().plusMinutes(5)); // Configurable expiration
        mfaToken.setUser(user);
        return mfaTokenRepository.save(mfaToken);
    }

    public boolean verifyMfaCode(String code, User user) {
        return mfaTokenRepository.findByMfaCodeAndUser(code, user)
                .filter(token -> token.getExpiryDate().isAfter(LocalDateTime.now()) && !token.getUsed())
                .map(token -> {
                    token.setUsed(true); // Mark token as used
                    mfaTokenRepository.save(token);
                    return true;
                }).orElse(false);
    }

    private String generateRandomMfaCode() {
        return String.valueOf(100000 + new Random().nextInt(900000)); // 6-digit random code
    }
}


==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/CTIMySQLFINAL/src/main/java/orsk/compli/service/auth/AuditLogService.java
==============================
package orsk.compli.service.auth;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import orsk.compli.entities.AuditLog;
import orsk.compli.repository.auth.AuditLogRepository;
import orsk.compli.entities.User;


import java.time.Instant;

@Service("AuditLogService")
public class AuditLogService {

    @Autowired
    private AuditLogRepository auditLogRepository;

    public void logAction(User user, String action, String ipAddress, String details) {
        AuditLog auditLog = new AuditLog();
        auditLog.setUser(user);
        auditLog.setAction(action);
        auditLog.setIpAddress(ipAddress);
        auditLog.setTimestamp(Instant.now());
        auditLog.setDetails(details);
        auditLogRepository.save(auditLog);
    }
}


==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/CTIMySQLFINAL/src/main/java/orsk/compli/service/auth/AuthService.java
==============================
package orsk.compli.service.auth;

import jakarta.servlet.http.HttpServletRequest;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.BadCredentialsException;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.validation.annotation.Validated;
import org.springframework.web.context.request.RequestContextHolder;
import org.springframework.web.context.request.ServletRequestAttributes;
import orsk.compli.dtos.auth.*;
import orsk.compli.entities.*;
import orsk.compli.exception.auth.EmailNotFoundException;
import orsk.compli.exception.auth.InvalidTokenException;
import orsk.compli.exception.auth.MfaRequiredException;
import orsk.compli.exception.auth.UserAlreadyExistsException;
import orsk.compli.repository.auth.*;
import orsk.compli.security.JwtTokenProvider;


import java.time.Instant;
import java.time.chrono.ChronoLocalDateTime;
import java.util.Optional;
import java.util.Set;
import java.util.UUID;

@Service("AuthService")
@Validated
@RequiredArgsConstructor
@Slf4j
public class AuthService {

    private final PasswordEncoder passwordEncoder;
    private final AuthenticationManager authenticationManager;
    private final UserRepository userRepository;
    private final RoleRepository roleRepository;
    private final VerificationTokenRepository verificationTokenRepository;
    private final PasswordResetTokenRepository passwordResetTokenRepository;
    private final JwtTokenProvider tokenProvider;
    private final RefreshTokenService refreshTokenService;
    private final MfaTokenService mfaTokenService;
    private final AuditLogService auditLogService;
    private final EmailService emailService;
    private final MfaTokenRepository mfaTokenRepository;

    private static final long VERIFICATION_TOKEN_EXPIRY = 86400L; // 24 hours
    private static final long PASSWORD_RESET_TOKEN_EXPIRY = 3600L; // 1 hour

    // User Registration
    @Transactional(rollbackFor = {UserAlreadyExistsException.class})
    public void registerUser(@Valid RegistrationRequest registrationRequest) {
        if (userRepository.existsByUsernameOrEmail(registrationRequest.getUsername(), registrationRequest.getEmail())) {
            throw new UserAlreadyExistsException("Username or email already exists");
        }

        User user = new User();
        user.setUsername(registrationRequest.getUsername());
        user.setPassword(passwordEncoder.encode(registrationRequest.getPassword()));
        user.setEmail(registrationRequest.getEmail());
        user.setConsentToDataUsage(Optional.of(registrationRequest.getConsentToDataUsage()).orElse(false));
        user.setEnabled(false);

        // Fetch the role from the database
        Role userRole = roleRepository.findByName("ROLE_USER")
                .orElseThrow(() -> new RuntimeException("ROLE_USER not found"));

        // Add the fetched role to the user
        user.getRoles().add(userRole);

        userRepository.save(user);

        String token = generateVerificationToken(user);
        log.info("Verification token generated for user {}: {}", user.getUsername(), token);

        emailService.sendVerificationEmail(user.getEmail(), token);

        auditLogService.logAction(user, "USER_REGISTERED", getClientIp(), "User registered successfully");
    }

    @Transactional
    public JwtAuthenticationResponse authenticateUser(@Valid LoginRequest loginRequest) {
        Authentication authentication = authenticate(loginRequest);

        User user = findUserByEmail(loginRequest.getEmail());
        validateUserEnabled(user);

        String jwt = tokenProvider.generateToken(authentication);
        RefreshToken refreshToken = refreshTokenService.createRefreshToken(user.getUsername());

        auditLogService.logAction(user, "LOGIN_SUCCESS", getClientIp(), "User logged in successfully");

        return JwtAuthenticationResponse.builder()
                .accessToken(jwt)
                .refreshToken(refreshToken.getToken())
                .build();
    }

    @Transactional
    public void logoutUser(@Valid LogoutRequest logoutRequest) {
        refreshTokenService.deleteByToken(logoutRequest.getRefreshToken());
        log.info("User logged out with refresh token {}", logoutRequest.getRefreshToken());
        auditLogService.logAction(null, "USER_LOGOUT", getClientIp(), "User logged out");
    }

    @Transactional
    public void changePassword(@Valid PasswordChangeRequest passwordChangeRequest) {
        PasswordResetToken resetToken = validatePasswordResetToken(passwordChangeRequest.getToken());
        User user = resetToken.getUser();

        user.setPassword(passwordEncoder.encode(passwordChangeRequest.getNewPassword()));
        userRepository.save(user);

        passwordResetTokenRepository.delete(resetToken);

        log.info("Password successfully changed for user {}", user.getUsername());
        auditLogService.logAction(user, "PASSWORD_CHANGED", getClientIp(), "User changed password successfully");
    }

    @Transactional
    public void verifyEmail(String token) {
        VerificationToken verificationToken = validateVerificationToken(token);

        User user = verificationToken.getUser();
        user.setEnabled(true);
        userRepository.save(user);
        verificationTokenRepository.delete(verificationToken);

        auditLogService.logAction(user, "EMAIL_VERIFIED", getClientIp(), "User verified email successfully");
    }

    @Transactional
    public void initiatePasswordReset(PasswordResetRequest passwordResetRequest) {
        User user = findUserByEmail(passwordResetRequest.getEmail());

        String token = UUID.randomUUID().toString();
        PasswordResetToken resetToken = createPasswordResetToken(user, token);

        emailService.sendPasswordResetEmail(user.getEmail(), token);
        auditLogService.logAction(user, "PASSWORD_RESET_INITIATED", getClientIp(), "User requested password reset");
    }

    @Transactional(readOnly = true)
    public UserProfileResponse getUserProfile(String username) {
        User user = findUserByUsername(username);

        return new UserProfileResponse(
                user.getUsername(),
                user.getEmail(),
                user.getRoles().stream().map(Role::getName).toList(),
                user.getEnabled()
        );
    }

    // Helper Methods

    private void validateUserExistence(String username, String email) {
        if (userRepository.existsByUsernameOrEmail(username, email)) {
            throw new UserAlreadyExistsException("Username or email already exists");
        }
    }

    private User createUser(RegistrationRequest registrationRequest) {
        Role userRole = roleRepository.findByName("ROLE_USER")
                .orElseThrow(() -> new RuntimeException("ROLE_USER not found"));

        User user = new User();
        user.setUsername(registrationRequest.getUsername());
        user.setPassword(passwordEncoder.encode(registrationRequest.getPassword()));
        user.setEmail(registrationRequest.getEmail());
        user.setConsentToDataUsage(Optional.of(registrationRequest.getConsentToDataUsage()).orElse(false));
        user.setEnabled(false);
        user.setRoles(Set.of(userRole));

        return userRepository.save(user);
    }

    private Authentication authenticate(LoginRequest loginRequest) {
        try {
            return authenticationManager.authenticate(
                    new UsernamePasswordAuthenticationToken(
                            loginRequest.getEmail(),
                            loginRequest.getPassword()
                    )
            );
        } catch (BadCredentialsException ex) {
            auditLogService.logAction(null, "LOGIN_FAILURE", getClientIp(), "Invalid credentials");
            throw ex;
        }
    }

    private User findUserByEmail(String email) {
        return userRepository.findByEmail(email)
                .orElseThrow(() -> new EmailNotFoundException("User not found with email: " + email));
    }

    private User findUserByUsername(String username) {
        return userRepository.findByUsername(username)
                .orElseThrow(() -> new UsernameNotFoundException("User not found with username: " + username));
    }

    private void validateUserEnabled(User user) {
        if (!Boolean.TRUE.equals(user.getEnabled())) {
            throw new RuntimeException("User account is not enabled");
        }
    }

    private PasswordResetToken createPasswordResetToken(User user, String token) {
        PasswordResetToken resetToken = new PasswordResetToken();
        resetToken.setUser(user);
        resetToken.setToken(token);
        resetToken.setExpiryDate(Instant.now().plusSeconds(PASSWORD_RESET_TOKEN_EXPIRY));
        return passwordResetTokenRepository.save(resetToken);
    }

    private VerificationToken validateVerificationToken(String token) {
        return verificationTokenRepository.findByToken(token)
                .orElseThrow(() -> new InvalidTokenException("Invalid verification token"));
    }

    private PasswordResetToken validatePasswordResetToken(String token) {
        PasswordResetToken resetToken = passwordResetTokenRepository.findByToken(token)
                .orElseThrow(() -> new InvalidTokenException("Invalid password reset token"));
        if (resetToken.getExpiryDate().isBefore(Instant.now())) {
            throw new InvalidTokenException("Password reset token expired");
        }
        return resetToken;
    }

    private String generateVerificationToken(User user) {
        String token = UUID.randomUUID().toString();
        VerificationToken verificationToken = new VerificationToken();
        verificationToken.setToken(token);
        verificationToken.setUser(user);
        verificationToken.setExpiryDate(Instant.now().plusSeconds(VERIFICATION_TOKEN_EXPIRY));
        verificationTokenRepository.save(verificationToken);
        return token;
    }

    private String getClientIp() {
        ServletRequestAttributes attrs = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();
        if (attrs == null) return "UNKNOWN_IP";
        HttpServletRequest request = attrs.getRequest();
        String ipAddress = request.getHeader("X-Forwarded-For");
        if (ipAddress == null || ipAddress.isBlank() || "unknown".equalsIgnoreCase(ipAddress)) {
            ipAddress = request.getRemoteAddr();
        }
        return ipAddress;
    }

    @Transactional
    public JwtAuthenticationResponse refreshToken(String refreshToken) {
        RefreshToken token = refreshTokenService.findByToken(refreshToken)
                .orElseThrow(() -> new InvalidTokenException("Invalid refresh token"));

        refreshTokenService.verifyExpiration(token);

        User user = token.getUser();
        String newAccessToken = tokenProvider.generateTokenFromUsername(user.getUsername());

        return JwtAuthenticationResponse.builder()
                .accessToken(newAccessToken)
                .refreshToken(refreshToken)
                .build();
    }
    @Transactional
    public void verifyMfa(MfaVerificationRequest mfaVerificationRequest) {
        MfaToken mfaToken = mfaTokenRepository.findByMfaCode(mfaVerificationRequest.getMfaCode())
                .orElseThrow(() -> new MfaRequiredException("Invalid MFA code"));

        if (mfaToken.getExpiryDate().isBefore(ChronoLocalDateTime.from(Instant.now())) || Boolean.TRUE.equals(mfaToken.getUsed())) {
            throw new MfaRequiredException("MFA code expired or already used");
        }

        mfaToken.setUsed(true);
        mfaTokenRepository.save(mfaToken);
        auditLogService.logAction(mfaToken.getUser(), "MFA_VERIFIED", getClientIp(), "User verified MFA successfully");
    }
/*
    private void sendMfaCode(String email, String mfaCode) {
        // Check if the user prefers SMS or email for MFA
        if (userPrefersSms) {
            // Use Twilio to send the MFA code via SMS
            Twilio.init(accountSid, authToken);
            Message message = Message.creator(new PhoneNumber("+1234567890"), "+0987654321", "Your MFA code is: " + mfaCode).create();
            log.info("MFA code sent via SMS: {}", message.getSid());
        } else {
            // Use Spring Boot's EmailSender to send the MFA code via email
            SimpleMailMessage mailMessage = new SimpleMailMessage();
            mailMessage.setFrom("noreply@example.com");
            mailMessage.setTo(email);
            mailMessage.setSubject("Your MFA Code");
            mailMessage.setText("Your MFA code is: " + mfaCode);
            emailSender.send(mailMessage);
            log.info("MFA code sent via email: {}", mailMessage.getSubject());
        }
    }

 */
}


==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/CTIMySQLFINAL/src/main/java/orsk/compli/service/auth/RefreshTokenService.java
==============================
package orsk.compli.service.auth;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import orsk.compli.entities.RefreshToken;
import orsk.compli.entities.User;
import orsk.compli.exception.auth.InvalidTokenException;
import orsk.compli.repository.auth.RefreshTokenRepository;
import orsk.compli.repository.auth.UserRepository;


import java.time.Instant;
import java.util.Optional;
import java.util.Set;
import java.util.UUID;
import java.util.concurrent.ConcurrentHashMap;

@Service("RefreshTokenService")
@RequiredArgsConstructor
@Slf4j
public class RefreshTokenService {

    private static final long REFRESH_TOKEN_EXPIRY = 604800L; // 7 days

    private final RefreshTokenRepository refreshTokenRepository;
    private final UserRepository userRepository;

    @Transactional
    public Optional<RefreshToken> findByToken(String token) {
        return refreshTokenRepository.findByToken(token);
    }

    @Transactional
    public RefreshToken createRefreshToken(String username) {
        User user = userRepository.findByUsername(username)
                .orElseThrow(() -> new RuntimeException("User not found for username: " + username));

        RefreshToken refreshToken = new RefreshToken();
        refreshToken.setUser(user);
        refreshToken.setExpiryDate(Instant.now().plusSeconds(REFRESH_TOKEN_EXPIRY));
        refreshToken.setToken(UUID.randomUUID().toString());

        log.debug("Created new refresh token for user: {}", username);
        return refreshTokenRepository.save(refreshToken);
    }

    @Transactional
    public RefreshToken verifyExpiration(RefreshToken token) {
        if (token.getExpiryDate().isBefore(Instant.now())) {
            refreshTokenRepository.delete(token);
            throw new InvalidTokenException("Refresh token expired");
        }
        return token;
    }

    @Transactional
    public void deleteByToken(String token) {
        findByToken(token).ifPresent(refreshToken -> {
            refreshTokenRepository.delete(refreshToken);
            log.debug("Deleted refresh token: {}", token);
        });
    }

    @Transactional
    public void revokeTokensForUser(Long userId) {
        User user = userRepository.findById(userId)
                .orElseThrow(() -> new RuntimeException("User not found with id: " + userId));
        int deletedCount = refreshTokenRepository.deleteByUser(user);
        log.debug("Revoked {} refresh tokens for user with id {}", deletedCount, userId);
    }

    @Service
    public static class TokenBlacklistService {
        private final Set<String> blacklist = ConcurrentHashMap.newKeySet();

        public void blacklistToken(String token) {
            blacklist.add(token);
        }

        public boolean isTokenBlacklisted(String token) {
            return blacklist.contains(token);
        }
    }
}


==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/CTIMySQLFINAL/src/main/java/orsk/compli/service/auth/EmailService.java
==============================
// src/main/java/orsk/authmodule/service/EmailService.java
package orsk.compli.service.auth;

import org.springframework.stereotype.Service;

@Service
public class EmailService {
    public void sendVerificationEmail(String to, String token) {
        // Implement email sending logic here
    }

    public void sendPasswordResetEmail(String to, String token) {
        // Implement email sending logic here
    }

    public void sendMfaCode(String to, String mfaCode) {
        // Implement email/SMS sending logic here
    }
}


==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/CTIMySQLFINAL/src/main/java/orsk/compli/service/auth/CustomUserDetailsService.java
==============================
package orsk.compli.service.auth;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import orsk.compli.entities.User;
import orsk.compli.repository.auth.UserRepository;
import orsk.compli.entities.Privilege;


import java.util.List;
import java.util.stream.Collectors;

@Service("CustomUserDetailsService")
public class CustomUserDetailsService implements UserDetailsService {

    private final UserRepository userRepository;

    @Autowired
    public CustomUserDetailsService(UserRepository userRepository) {
        this.userRepository = userRepository;
    }

    @Override
    @Transactional(readOnly = true)
    public UserDetails loadUserByUsername(String usernameOrEmail) throws UsernameNotFoundException {
        User user = userRepository.findByUsername(usernameOrEmail)
                .or(() -> userRepository.findByEmail(usernameOrEmail))
                .orElseThrow(() -> new UsernameNotFoundException("User not found with username or email: " + usernameOrEmail));

        List<SimpleGrantedAuthority> authorities = getAuthorities(user);

        return new org.springframework.security.core.userdetails.User(
                user.getUsername(),
                user.getPassword(),
                user.getEnabled(),
                true, // accountNonExpired
                true, // credentialsNonExpired
                true, // accountNonLocked
                authorities);
    }

    private List<SimpleGrantedAuthority> getAuthorities(User user) {
        return user.getRoles().stream()
                .flatMap(role -> role.getPrivileges().stream())
                .map(Privilege::getName)
                .distinct()
                .map(SimpleGrantedAuthority::new)
                .collect(Collectors.toList());
    }
}


==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/CTIMySQLFINAL/src/main/java/orsk/compli/service/jpa/VulnerabilityJpaService.java
==============================
package orsk.compli.service.jpa;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Service;
import orsk.compli.dtos.jpa.VulnerabilityDTO;
import orsk.compli.entities.Vulnerability;
import orsk.compli.repository.jpa.VulnerabilityJpaRepository;

/**
 * Service class for managing Vulnerability entities.
 */
@Service("jpaVulnerabilityService")
public class VulnerabilityJpaService extends AbstractGenericService<Vulnerability, Long> {

    private final VulnerabilityJpaRepository vulnerabilityRepository;

    @Autowired
    public VulnerabilityJpaService(VulnerabilityJpaRepository vulnerabilityRepository) {
        this.vulnerabilityRepository = vulnerabilityRepository;
    }

    @Override
    protected JpaRepository<Vulnerability, Long> getRepository() {
        return vulnerabilityRepository;
    }

    @Override
    protected Vulnerability updateEntity(Vulnerability existing, Vulnerability updated) {
        existing.setCveId(updated.getCveId());
        existing.setDescription(updated.getDescription());
        existing.setPublishedDate(updated.getPublishedDate());
        existing.setSeverityScore(updated.getSeverityScore());
        // Add other field mappings as necessary
        return existing;
    }
}


==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/CTIMySQLFINAL/src/main/java/orsk/compli/service/jpa/CountryJpaService.java
==============================
package orsk.compli.service.jpa;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Service;
import orsk.compli.entities.Country;
import orsk.compli.repository.jpa.CountryJpaRepository;

/**
 * Service class for managing Country entities.
 */
@Service("jpaCountryService")
public class CountryJpaService extends AbstractGenericService<Country, Long> {

    private final CountryJpaRepository countryRepository;

    @Autowired
    public CountryJpaService(CountryJpaRepository countryRepository) {
        this.countryRepository = countryRepository;
    }

    @Override
    protected JpaRepository<Country, Long> getRepository() {
        return countryRepository;
    }

    @Override
    protected Country updateEntity(Country existing, Country updated) {
        existing.setCountryCode(updated.getCountryCode());
        existing.setCountryName(updated.getCountryName());
        //existing.setDescription(updated.getDescription());
        // Add other field mappings as necessary
        return existing;
    }
}


==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/CTIMySQLFINAL/src/main/java/orsk/compli/service/jpa/GlobalThreatJpaService.java
==============================
package orsk.compli.service.jpa;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Service;
import orsk.compli.entities.GlobalThreat;
import orsk.compli.repository.jpa.GlobalThreatJpaRepository;

/**
 * Service class for managing GlobalThreat entities.
 */
@Service("jpaGlobalThreatService")
public class GlobalThreatJpaService extends AbstractGenericService<GlobalThreat, Long> {

    private final GlobalThreatJpaRepository globalThreatRepository;

    @Autowired
    public GlobalThreatJpaService(GlobalThreatJpaRepository globalThreatRepository) {
        this.globalThreatRepository = globalThreatRepository;
    }

    @Override
    protected JpaRepository<GlobalThreat, Long> getRepository() {
        return globalThreatRepository;
    }

    @Override
    protected GlobalThreat updateEntity(GlobalThreat existing, GlobalThreat updated) {
        existing.setName(updated.getName());
        existing.setDescription(updated.getDescription());
        existing.setFirstDetected(updated.getFirstDetected());
        existing.setLastUpdated(updated.getLastUpdated());
        existing.setSeverityLevel(updated.getSeverityLevel());
        // Add other field mappings as necessary
        return existing;
    }
}


==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/CTIMySQLFINAL/src/main/java/orsk/compli/service/jpa/ThreatActorTypeJpaService.java
==============================
package orsk.compli.service.jpa;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Service;
import orsk.compli.entities.ThreatActorType;
import orsk.compli.repository.jpa.ThreatActorTypeJpaRepository;

/**
 * Service class for managing ThreatActorType entities.
 */
@Service("jpaThreatActorTypeService")
public class ThreatActorTypeJpaService extends AbstractGenericService<ThreatActorType, Long> {

    private final ThreatActorTypeJpaRepository threatActorTypeRepository;

    @Autowired
    public ThreatActorTypeJpaService(ThreatActorTypeJpaRepository threatActorTypeRepository) {
        this.threatActorTypeRepository = threatActorTypeRepository;
    }

    @Override
    protected JpaRepository<ThreatActorType, Long> getRepository() {
        return threatActorTypeRepository;
    }

    @Override
    protected ThreatActorType updateEntity(ThreatActorType existing, ThreatActorType updated) {
        existing.setTypeName(updated.getTypeName());
        existing.setDescription(updated.getDescription());
        // Add other field mappings as necessary
        return existing;
    }
}


==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/CTIMySQLFINAL/src/main/java/orsk/compli/service/jpa/AuthClientService.java
==============================
package orsk.compli.service.jpa;

import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;
import orsk.compli.dtos.auth.JwtAuthenticationResponse;
import orsk.compli.dtos.auth.LoginRequest;
import orsk.compli.dtos.auth.TokenRefreshRequest;
import orsk.compli.dtos.auth.LogoutRequest;
import orsk.compli.dtos.auth.TokenRefreshRequest;

/**
 * Service class for handling authentication-related operations via external services.
 */
@Service
@Slf4j
public class AuthClientService {

    private final RestTemplate restTemplate;

    @Value("${auth.service.url:http://localhost:8087/api/auth}")
    private String authServiceUrl;

    @Autowired
    public AuthClientService(RestTemplate restTemplate) {
        this.restTemplate = restTemplate;
    }

    /**
     * Sends a login request to the authentication service.
     *
     * @param loginRequest The login request payload
     * @return The authentication response containing JWT tokens
     */
    public JwtAuthenticationResponse login(LoginRequest loginRequest) {
        String url = authServiceUrl + "/login";
        try {
            log.info("Sending login request to {}", url);
            ResponseEntity<JwtAuthenticationResponse> response =
                    restTemplate.postForEntity(url, loginRequest, JwtAuthenticationResponse.class);
            if (response == null || response.getBody() == null) {
                throw new RuntimeException("Authentication service returned null response for login");
            }
            return response.getBody();
        } catch (Exception ex) {
            log.error("Error during login: {}", ex.getMessage());
            throw new RuntimeException("Failed to login: " + ex.getMessage(), ex);
        }
    }

    /**
     * Sends a refresh token request to the authentication service.
     *
     * @param refreshToken The refresh token string
     * @return The authentication response containing new JWT tokens
     */
    public JwtAuthenticationResponse refreshToken(String refreshToken) {
        String url = authServiceUrl + "/refresh-token";
        try {
            log.info("Sending refresh token request to {}", url);
            TokenRefreshRequest request = new TokenRefreshRequest(refreshToken);
            ResponseEntity<JwtAuthenticationResponse> response =
                    restTemplate.postForEntity(url, request, JwtAuthenticationResponse.class);
            if (response == null || response.getBody() == null) {
                throw new RuntimeException("Authentication service returned null response for refresh token");
            }
            return response.getBody();
        } catch (Exception ex) {
            log.error("Error during refresh token: {}", ex.getMessage());
            throw new RuntimeException("Failed to refresh token: " + ex.getMessage(), ex);
        }
    }

    /**
     * Sends a logout request to the authentication service.
     *
     * @param token The JWT token to invalidate
     */
    public void logout(String token) {
        String url = authServiceUrl + "/logout";
        try {
            log.info("Sending logout request to {}", url);
            LogoutRequest request = new LogoutRequest(token);
            restTemplate.postForEntity(url, request, Void.class);
            log.info("User successfully logged out");
        } catch (Exception ex) {
            log.error("Error during logout: {}", ex.getMessage());
            throw new RuntimeException("Failed to logout: " + ex.getMessage(), ex);
        }
    }
}


==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/CTIMySQLFINAL/src/main/java/orsk/compli/service/jpa/GeolocationJpaService.java
==============================
package orsk.compli.service.jpa;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Service;
import orsk.compli.entities.Geolocation;
import orsk.compli.repository.jpa.GeolocationJpaRepository;

/**
 * Service class for managing Geolocation entities.
 */
@Service("jpaGeolocationService")
public class GeolocationJpaService extends AbstractGenericService<Geolocation, Long> {

    private final GeolocationJpaRepository geolocationRepository;

    @Autowired
    public GeolocationJpaService(GeolocationJpaRepository geolocationRepository) {
        this.geolocationRepository = geolocationRepository;
    }

    @Override
    protected JpaRepository<Geolocation, Long> getRepository() {
        return geolocationRepository;
    }

    @Override
    protected Geolocation updateEntity(Geolocation existing, Geolocation updated) {
        existing.setIpAddress(updated.getIpAddress());
        existing.setCountry(updated.getCountry());
        existing.setRegion(updated.getRegion());
        existing.setCity(updated.getCity());
        existing.setLatitude(updated.getLatitude());
        existing.setLongitude(updated.getLongitude());
        // Add other field mappings as necessary
        return existing;
    }
}


==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/CTIMySQLFINAL/src/main/java/orsk/compli/service/jpa/AttackVectorJpaService.java
==============================
package orsk.compli.service.jpa;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Service;
import orsk.compli.entities.AttackVector;
import orsk.compli.repository.jpa.AttackVectorJpaRepository;

/**
 * Service class for managing AttackVector entities.
 */
@Service("jpaAttackVectorService")
public class AttackVectorJpaService extends AbstractGenericService<AttackVector, Long> {

    private final AttackVectorJpaRepository attackVectorRepository;

    @Autowired
    public AttackVectorJpaService(AttackVectorJpaRepository attackVectorRepository) {
        this.attackVectorRepository = attackVectorRepository;
    }

    @Override
    protected JpaRepository<AttackVector, Long> getRepository() {
        return attackVectorRepository;
    }

    @Override
    protected AttackVector updateEntity(AttackVector existing, AttackVector updated) {
       // existing.setName(updated.getName());
        existing.setDescription(updated.getDescription());
        existing.setSeverityLevel(updated.getSeverityLevel());
        // Add other field mappings as necessary
        return existing;
    }
}


==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/CTIMySQLFINAL/src/main/java/orsk/compli/service/jpa/AbstractGenericService.java
==============================
package orsk.compli.service.jpa;

import jakarta.transaction.Transactional;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.dao.DataAccessException;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.security.access.prepost.PreAuthorize;

import orsk.compli.exception.DatabaseOperationException;

import java.util.List;
import java.util.Optional;

/**
 * An abstract generic service providing CRUD operations.
 *
 * @param <T>  Entity type
 * @param <ID> Identifier type
 */
public abstract class AbstractGenericService<T, ID> implements CrudService<T, ID> {

    protected final Logger LOGGER = LoggerFactory.getLogger(getClass());

    /**
     * Provides the specific repository for the entity.
     *
     * @return JpaRepository for the entity
     */
    protected abstract JpaRepository<T, ID> getRepository();

    /**
     * Batch creation of entities.
     *
     * @param entities List of entities to be created
     * @return List of saved entities
     */
    @Override
    @Transactional
    //@PreAuthorize("hasRole('ADMIN')")
    public List<T> createAll(List<T> entities) {
        if (entities == null || entities.isEmpty()) {
            LOGGER.warn("Attempted to create an empty or null list of entities.");
            throw new IllegalArgumentException("Entity list must not be null or empty.");
        }

        try {
            LOGGER.info("Batch creating entities of type: {}", entities.get(0).getClass().getSimpleName());
            return getRepository().saveAll(entities);
        } catch (DataAccessException e) {
            LOGGER.error("Error creating entities: {}", e.getMessage());
            throw new DatabaseOperationException("Error creating entities", entities.toString());
        }
    }

    /**
     * Creates a single entity.
     *
     * @param entity The entity to create
     * @return The created entity
     */
    @Override
    @Transactional
    //@PreAuthorize("hasRole('ADMIN')")
    public T create(T entity) {
        if (entity == null) {
            LOGGER.warn("Attempted to create a null entity.");
            throw new IllegalArgumentException("Entity must not be null.");
        }

        try {
            LOGGER.info("Creating entity of type: {}", entity.getClass().getSimpleName());
            return getRepository().save(entity);
        } catch (DataAccessException e) {
            LOGGER.error("Error creating entity: {}", e.getMessage());
            throw new DatabaseOperationException("Error creating entity", entity.toString());
        }
    }

    /**
     * Retrieves all entities.
     *
     * @return List of all entities
     */
    @Override
    @Transactional
    //@PreAuthorize("hasAnyRole('ADMIN', 'USER')")
    public List<T> getAll() {
        try {
            LOGGER.info("Retrieving all entities of type: {}", getEntityClassName());
            return getRepository().findAll();
        } catch (DataAccessException e) {
            LOGGER.error("Error retrieving all entities: {}", e.getMessage());
            throw new DatabaseOperationException("Error retrieving all entities", e.getMessage());
        }
    }

    /**
     * Retrieves an entity by its ID.
     *
     * @param id The ID of the entity
     * @return Optional containing the entity if found, or empty if not found
     */
    @Override
    @Transactional
    //@PreAuthorize("hasAnyRole('ADMIN', 'USER')")
    public Optional<T> getById(ID id) {
        try {
            LOGGER.info("Retrieving entity of type: {} with ID: {}", getEntityClassName(), id);
            return getRepository().findById(id);
        } catch (DataAccessException e) {
            LOGGER.error("Error retrieving entity by ID: {}", e.getMessage());
            throw new DatabaseOperationException("Error retrieving entity by ID", id.toString());
        }
    }

    /**
     * Updates an existing entity by its ID.
     *
     * @param id     The ID of the entity to update
     * @param entity The updated entity data
     * @return The updated entity
     */
    @Override
    @Transactional
    //@PreAuthorize("hasRole('ADMIN')")
    public T update(ID id, T entity) {
        if (entity == null) {
            LOGGER.warn("Attempted to update a null entity.");
            throw new IllegalArgumentException("Entity must not be null.");
        }

        try {
            LOGGER.info("Updating entity of type: {} with ID: {}", getEntityClassName(), id);
            return getRepository().findById(id)
                    .map(existing -> updateEntity(existing, entity))
                    .map(getRepository()::save)
                    .orElseThrow(() -> new orsk.compli.exception.EntityNotFoundException(
                            String.format("Entity not found with id %s", id)));
        } catch (DataAccessException e) {
            LOGGER.error("Error updating entity: {}", e.getMessage());
            throw new DatabaseOperationException("Error updating entity", entity.toString());
        }
    }

    /**
     * Deletes an entity by its ID.
     *
     * @param id The ID of the entity to delete
     * @return True if the entity was deleted, false if not found
     */
    @Override
    @Transactional
    //@PreAuthorize("hasRole('ADMIN')")
    public boolean delete(ID id) {
        try {
            LOGGER.info("Deleting entity of type: {} with ID: {}", getEntityClassName(), id);
            if (getRepository().existsById(id)) {
                getRepository().deleteById(id);
                LOGGER.info("Entity with ID: {} deleted successfully.", id);
                return true;
            }
            LOGGER.warn("Entity with ID: {} not found for deletion.", id);
            return false;
        } catch (DataAccessException e) {
            LOGGER.error("Error deleting entity: {}", e.getMessage());
            throw new DatabaseOperationException("Error deleting entity", id.toString());
        }
    }

    /**
     * Provides the simple name of the entity class.
     *
     * @return The simple class name of the entity
     */
    private String getEntityClassName() {
        return getRepository().getClass().getSimpleName();
    }

    /**
     * Defines how to update an existing entity with new values.
     * This method should be overridden by subclasses to handle specific field mappings.
     *
     * @param existing The existing entity fetched from the database
     * @param updated  The new entity data
     * @return The updated entity
     */
    protected abstract T updateEntity(T existing, T updated);
}


==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/CTIMySQLFINAL/src/main/java/orsk/compli/service/jpa/AffectedProductJpaService.java
==============================
package orsk.compli.service.jpa;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Service;
import orsk.compli.entities.AffectedProduct;
import orsk.compli.repository.jpa.AffectedProductJpaRepository;

/**
 * Service class for managing AffectedProduct entities.
 */
@Service("jpaAffectedProductService")
public class AffectedProductJpaService extends AbstractGenericService<AffectedProduct, Long> {

    private final AffectedProductJpaRepository affectedProductRepository;

    @Autowired
    public AffectedProductJpaService(AffectedProductJpaRepository affectedProductRepository) {
        this.affectedProductRepository = affectedProductRepository;
    }

    @Override
    protected JpaRepository<AffectedProduct, Long> getRepository() {
        return affectedProductRepository;
    }

    @Override
    protected AffectedProduct updateEntity(AffectedProduct existing, AffectedProduct updated) {
        existing.setProductName(updated.getProductName());
        existing.setVendor(updated.getVendor());
        existing.setVersion(updated.getVersion());
        // Add other field mappings as necessary
        return existing;
    }
}


==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/CTIMySQLFINAL/src/main/java/orsk/compli/service/jpa/ThreatCategoryJpaService.java
==============================
package orsk.compli.service.jpa;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Service;
import orsk.compli.entities.ThreatCategory;
import orsk.compli.repository.jpa.ThreatCategoryJpaRepository;

/**
 * Service class for managing ThreatCategory entities.
 */
@Service("jpaThreatCategoryService")
public class ThreatCategoryJpaService extends AbstractGenericService<ThreatCategory, Long> {

    private final ThreatCategoryJpaRepository threatCategoryRepository;

    @Autowired
    public ThreatCategoryJpaService(ThreatCategoryJpaRepository threatCategoryRepository) {
        this.threatCategoryRepository = threatCategoryRepository;
    }

    @Override
    protected JpaRepository<ThreatCategory, Long> getRepository() {
        return threatCategoryRepository;
    }

    @Override
    protected ThreatCategory updateEntity(ThreatCategory existing, ThreatCategory updated) {
        existing.setCategoryName(updated.getCategoryName());
        existing.setDescription(updated.getDescription());
        // Add other field mappings as necessary
        return existing;
    }
}


==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/CTIMySQLFINAL/src/main/java/orsk/compli/service/jpa/RefreshTokenJpaService.java
==============================
package orsk.compli.service.jpa;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import orsk.compli.entities.RefreshToken;
import orsk.compli.entities.User;
import orsk.compli.exception.InvalidTokenException;
import orsk.compli.exception.UserNotFoundException;
import orsk.compli.repository.auth.RefreshTokenRepository;
import orsk.compli.repository.auth.UserRepository;

import java.time.Instant;
import java.util.Optional;
import java.util.UUID;

/**
 * Service class for managing RefreshToken entities.
 */
@Service("jpaRefreshTokenService")
public class RefreshTokenJpaService {

    private final Logger LOGGER = LoggerFactory.getLogger(RefreshTokenJpaService.class);

    private final RefreshTokenRepository refreshTokenRepository;
    private final UserRepository userRepository;

    @Autowired
    public RefreshTokenJpaService(RefreshTokenRepository refreshTokenRepository, UserRepository userRepository) {
        this.refreshTokenRepository = refreshTokenRepository;
        this.userRepository = userRepository;
    }

    /**
     * Finds a RefreshToken by its token string.
     *
     * @param token The token string
     * @return Optional containing the RefreshToken if found
     */
    public Optional<RefreshToken> findByToken(String token) {
        LOGGER.info("Finding Refresh Token: {}", token);
        return refreshTokenRepository.findByToken(token);
    }

    /**
     * Creates a new RefreshToken for a given username.
     *
     * @param username The username of the user
     * @return The created RefreshToken
     */
    @Transactional
    @PreAuthorize("isAuthenticated()")
    public RefreshToken createRefreshToken(String username) {
        LOGGER.info("Creating Refresh Token for user: {}", username);
        RefreshToken refreshToken = new RefreshToken();

        User user = userRepository.findByUsername(username)
                .orElseThrow(() -> new UserNotFoundException("User not found"));

        refreshToken.setUser(user);
        refreshToken.setExpiryDate(Instant.now().plusSeconds(604800)); // 7 days
        refreshToken.setToken(UUID.randomUUID().toString());

        RefreshToken savedToken = refreshTokenRepository.save(refreshToken);
        LOGGER.info("Refresh Token created: {}", savedToken.getToken());
        return savedToken;
    }

    /**
     * Verifies if the RefreshToken has expired.
     *
     * @param token The RefreshToken to verify
     * @return The valid RefreshToken
     * @throws InvalidTokenException If the token has expired
     */
    public RefreshToken verifyExpiration(RefreshToken token) {
        LOGGER.info("Verifying expiration for Refresh Token: {}", token.getToken());
        if (token.getExpiryDate().isBefore(Instant.now())) {
            LOGGER.warn("Refresh Token expired: {}", token.getToken());
            refreshTokenRepository.delete(token);
            throw new InvalidTokenException("Refresh token expired");
        }
        return token;
    }

    /**
     * Deletes all RefreshTokens associated with a user ID.
     *
     * @param userId The ID of the user
     * @return The number of tokens deleted
     */
    @Transactional
    @PreAuthorize("isAuthenticated()")
    public int deleteByUserId(Long userId) {
        LOGGER.info("Deleting Refresh Tokens for User ID: {}", userId);
        User user = userRepository.findById(userId)
                .orElseThrow(() -> new UserNotFoundException("User not found"));
        return refreshTokenRepository.deleteByUser(user);
    }

    /**
     * Deletes a RefreshToken by its token string.
     *
     * @param token The token string
     */
    @Transactional
    @PreAuthorize("isAuthenticated()")
    public void deleteByToken(String token) {
        LOGGER.info("Deleting Refresh Token: {}", token);
        refreshTokenRepository.findByToken(token).ifPresent(rt -> {
            refreshTokenRepository.delete(rt);
            LOGGER.info("Refresh Token deleted: {}", token);
        });
    }
}


==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/CTIMySQLFINAL/src/main/java/orsk/compli/service/jpa/SearchService.java
==============================
package orsk.compli.service.jpa;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import orsk.compli.repository.jpa.AffectedProductJpaRepository;
import orsk.compli.repository.jpa.CountryJpaRepository;
import orsk.compli.repository.jpa.GlobalThreatJpaRepository;

import java.util.List;

import static org.hibernate.sql.ast.SqlTreeCreationLogger.LOGGER;

/**
 * Service class for performing search operations across multiple entities.
 */
@Service("jpaSearchService")
public class SearchService {

    private final AffectedProductJpaRepository affectedProductRepository;
    private final CountryJpaRepository countryRepository;
    private final GlobalThreatJpaRepository globalThreatRepository;

    @Autowired
    public SearchService(AffectedProductJpaRepository affectedProductRepository,
                         CountryJpaRepository countryRepository,
                         GlobalThreatJpaRepository globalThreatRepository) {
        this.affectedProductRepository = affectedProductRepository;
        this.countryRepository = countryRepository;
        this.globalThreatRepository = globalThreatRepository;
    }

    /**
     * Fetches all affected product names.
     *
     * @return List of affected product names
     */
    public List<String> getAffectedProductNames() {
        LOGGER.info("Fetching Affected Product Names");
        return affectedProductRepository.findAllProductNames();
    }

    /**
     * Fetches all country names.
     *
     * @return List of country names
     */
    public List<String> getCountryNames() {
        LOGGER.info("Fetching Country Names");
        return countryRepository.findAllCountryNames();
    }

    /**
     * Fetches all global threat names.
     *
     * @return List of global threat names
     */
    public List<String> getGlobalThreatNames() {
        LOGGER.info("Fetching Global Threat Names");
        return globalThreatRepository.findAllThreatNames();
    }

    // Add more search methods as needed with appropriate logging and security
}


==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/CTIMySQLFINAL/src/main/java/orsk/compli/service/jpa/AttackVectorCategoryJpaService.java
==============================
package orsk.compli.service.jpa;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Service;
import orsk.compli.entities.AttackVectorCategory;
import orsk.compli.repository.jpa.AttackVectorCategoryJpaRepository;

/**
 * Service class for managing AttackVectorCategory entities.
 */
@Service("jpaAttackVectorCategoryService")
public class AttackVectorCategoryJpaService extends AbstractGenericService<AttackVectorCategory, Long> {

    private final AttackVectorCategoryJpaRepository attackVectorCategoryRepository;

    @Autowired
    public AttackVectorCategoryJpaService(AttackVectorCategoryJpaRepository attackVectorCategoryRepository) {
        this.attackVectorCategoryRepository = attackVectorCategoryRepository;
    }

    @Override
    protected JpaRepository<AttackVectorCategory, Long> getRepository() {
        return attackVectorCategoryRepository;
    }

    @Override
    protected AttackVectorCategory updateEntity(AttackVectorCategory existing, AttackVectorCategory updated) {
        existing.setCategoryName(updated.getCategoryName());
        existing.setDescription(updated.getDescription());
        // Add other field mappings as necessary
        return existing;
    }
}


==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/CTIMySQLFINAL/src/main/java/orsk/compli/service/jpa/CrudService.java
==============================
package orsk.compli.service.jpa;

import java.util.List;
import java.util.Optional;

/**
 * A generic interface for CRUD operations.
 *
 * @param <T>  Entity type
 * @param <ID> Identifier type
 */
public interface CrudService<T, ID> {

    /**
     * Creates a single entity.
     *
     * @param dto The entity to create
     * @return The created entity
     */
    T create(T dto);

    /**
     * Creates multiple entities in a batch.
     *
     * @param dtos The list of entities to create
     * @return The list of created entities
     */
    List<T> createAll(List<T> dtos);

    /**
     * Retrieves all entities.
     *
     * @return List of all entities
     */
    List<T> getAll();

    /**
     * Retrieves an entity by its ID.
     *
     * @param id The ID of the entity
     * @return Optional containing the entity if found, or empty if not found
     */
    Optional<T> getById(ID id);

    /**
     * Updates an existing entity by its ID.
     *
     * @param id     The ID of the entity to update
     * @param dto The updated entity data
     * @return The updated entity
     */
    T update(ID id, T dto);

    /**
     * Deletes an entity by its ID.
     *
     * @param id The ID of the entity to delete
     * @return True if the entity was deleted, false if not found
     */
    boolean delete(ID id);
}


==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/CTIMySQLFINAL/src/main/java/orsk/compli/service/jpa/ThreatActorJpaService.java
==============================
package orsk.compli.service.jpa;

import jakarta.transaction.Transactional;
import org.hibernate.Hibernate;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Service;
import orsk.compli.dtos.jpa.ThreatActorDTO;
import orsk.compli.entities.ThreatActor;
import orsk.compli.exception.EntityNotFoundException;
import orsk.compli.mappers.ThreatActorMapper;
import orsk.compli.repository.jpa.ThreatActorJpaRepository;

import java.util.List;
import java.util.stream.Collectors;

/**
 * Service class for managing ThreatActor entities.
 */
@Service("jpaThreatActorService")
public class ThreatActorJpaService extends AbstractGenericService<ThreatActor, Long> {

    private static final Logger LOGGER = LoggerFactory.getLogger(ThreatActorJpaService.class);

    private final ThreatActorJpaRepository threatActorRepository;
    private final ThreatActorMapper mapper;

    @Autowired
    public ThreatActorJpaService(ThreatActorJpaRepository threatActorRepository, ThreatActorMapper mapper) {
        this.threatActorRepository = threatActorRepository;
        this.mapper = mapper;
    }

    @Override
    protected JpaRepository<ThreatActor, Long> getRepository() {
        return threatActorRepository;
    }

    /**
     * Find ThreatActor by ID and return as a DTO to the caller (controller).
     */
    @Transactional
    public ThreatActorDTO findThreatActorByIdAsDto(Integer id) {
        // Pull entity (with EAGER loads via EntityGraph or custom queries)
        ThreatActor entity = threatActorRepository.findById(id)
                .orElseThrow(() -> new EntityNotFoundException("ThreatActor with ID " + id + " not found"));

        // Initialize lazy fields if needed (for advanced usage).
        Hibernate.initialize(entity.getType());
        Hibernate.initialize(entity.getOriginCountry());
        Hibernate.initialize(entity.getCategory());
        Hibernate.initialize(entity.getAttackVectors());

        // Convert to DTO
        return mapper.toDto(entity);
    }

    /**
     * Fetch all ThreatActors as DTOs.
     */
    @Transactional
    public List<ThreatActorDTO> findAllAsDto() {
        LOGGER.info("Fetching all ThreatActors as DTOs");
        return threatActorRepository.findAll()
                .stream()
                .map(mapper::toDto)
                .collect(Collectors.toList());
    }

    @Override
    @Transactional
    protected ThreatActor updateEntity(ThreatActor existing, ThreatActor updated) {
        LOGGER.info("Updating ThreatActor with ID: {}", existing.getId());

        // Example partial update
        if (updated.getActorName() != null) {
            existing.setActorName(updated.getActorName());
        }
        if (updated.getMotivation() != null) {
            existing.setMotivation(updated.getMotivation());
        }
        if (updated.getCapabilities() != null) {
            existing.setCapabilities(updated.getCapabilities());
        }
        if (updated.getType() != null) {
            existing.setType(updated.getType());
        }
        if (updated.getDescription() != null) {
            existing.setDescription(updated.getDescription());
        }
        if (updated.getOriginCountry() != null) {
            existing.setOriginCountry(updated.getOriginCountry());
        }
        if (updated.getFirstObserved() != null) {
            existing.setFirstObserved(updated.getFirstObserved());
        }
        if (updated.getLastActivity() != null) {
            existing.setLastActivity(updated.getLastActivity());
        }
        if (updated.getCategory() != null) {
            existing.setCategory(updated.getCategory());
        }
        if (updated.getAttackVectors() != null) {
            existing.setAttackVectors(updated.getAttackVectors());
        }

        // Timestamps
        existing.setUpdatedAt(updated.getUpdatedAt() != null ? updated.getUpdatedAt() : existing.getUpdatedAt());

        return existing;
    }
}


==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/CTIMySQLFINAL/src/main/java/orsk/compli/exception/ResourceNotFoundException.java
==============================
package orsk.compli.exception;

public class ResourceNotFoundException extends RuntimeException {
    public ResourceNotFoundException(String message) {
        super(message);
    }
}




==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/CTIMySQLFINAL/src/main/java/orsk/compli/exception/auth/ResourceNotFoundException.java
==============================
package orsk.compli.exception.auth;

public class ResourceNotFoundException extends RuntimeException {
    public ResourceNotFoundException(String message) {
        super(message);
    }
}




==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/CTIMySQLFINAL/src/main/java/orsk/compli/exception/auth/EmailNotFoundException.java
==============================
package orsk.compli.exception.auth;

public class EmailNotFoundException extends RuntimeException {
    public EmailNotFoundException(String message) {
        super(message);
    }
}


==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/CTIMySQLFINAL/src/main/java/orsk/compli/exception/auth/MfaRequiredException.java
==============================
package orsk.compli.exception.auth;

public class MfaRequiredException extends RuntimeException {
    public MfaRequiredException(String message) {
        super(message);
    }
}


==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/CTIMySQLFINAL/src/main/java/orsk/compli/exception/auth/BadRequestException.java
==============================
package orsk.compli.exception.auth;

public class BadRequestException extends RuntimeException {
    public BadRequestException(String message) {
        super(message);
    }
}




==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/CTIMySQLFINAL/src/main/java/orsk/compli/exception/auth/UserAlreadyExistsException.java
==============================
package orsk.compli.exception.auth;

public class UserAlreadyExistsException extends RuntimeException {
    public UserAlreadyExistsException(String message) {
        super(message);
    }
}


==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/CTIMySQLFINAL/src/main/java/orsk/compli/exception/auth/InvalidTokenException.java
==============================
package orsk.compli.exception.auth;

public class InvalidTokenException extends RuntimeException {
    public InvalidTokenException(String message) {
        super(message);
    }
}


==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/CTIMySQLFINAL/src/main/java/orsk/compli/exception/auth/ErrorResponse.java
==============================
package orsk.compli.exception.auth;

import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.Setter;

import java.time.Instant;

@Getter
@Setter
@AllArgsConstructor
public class ErrorResponse {
    private Instant timestamp;
    private int status;
    private String error;
    private String message;
}




==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/CTIMySQLFINAL/src/main/java/orsk/compli/exception/UserNotFoundException.java
==============================
package orsk.compli.exception;

/**
 * Custom exception to handle cases where a user is not found.
 */
public class UserNotFoundException extends RuntimeException {

    private static final long serialVersionUID = 1L;

    private final Object userIdOrEmail;

    /**
     * Constructs a new UserNotFoundException with the specified identifier.
     *
     * @param userIdOrEmail the user ID or email that was not found
     */
    public UserNotFoundException(Object userIdOrEmail) {
        super(String.format("User not found with identifier: %s", userIdOrEmail));
        this.userIdOrEmail = userIdOrEmail;
    }

    /**
     * Gets the identifier of the user that was not found.
     *
     * @return the user identifier
     */
    public Object getUserIdOrEmail() {
        return userIdOrEmail;
    }
}


==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/CTIMySQLFINAL/src/main/java/orsk/compli/exception/EntityNotFoundException.java
==============================
package orsk.compli.exception;

/**
 * Custom exception to handle cases where a requested entity is not found.
 * This exception extends RuntimeException, making it an unchecked exception.
 */
public class EntityNotFoundException extends RuntimeException {

    private static final long serialVersionUID = 1L;

    private final String entityName;
    private final Object identifier;

    /**
     * Constructs a new EntityNotFoundException with the specified details.
     *
     * @param entityName the name of the entity that was not found
     * @param identifier the identifier of the entity that was not found
     */
    public EntityNotFoundException(String entityName, Object identifier) {
        super(String.format("%s not found with identifier: %s", entityName, identifier));
        this.entityName = entityName;
        this.identifier = identifier;
    }

    /**
     * Constructs a new EntityNotFoundException with a custom message.
     *
     * @param message the custom message
     */
    public EntityNotFoundException(String message) {
        super(message);
        this.entityName = null;
        this.identifier = null;
    }

    /**
     * Gets the name of the entity that was not found.
     *
     * @return the name of the entity
     */
    public String getEntityName() {
        return entityName;
    }

    /**
     * Gets the identifier of the entity that was not found.
     *
     * @return the identifier of the entity
     */
    public Object getIdentifier() {
        return identifier;
    }
}


==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/CTIMySQLFINAL/src/main/java/orsk/compli/exception/RoleNotFoundException.java
==============================
package orsk.compli.exception;

/**
 * Custom exception to handle cases where a role is not found.
 */
public class RoleNotFoundException extends RuntimeException {

    private static final long serialVersionUID = 1L;

    private final String roleName;

    /**
     * Constructs a new RoleNotFoundException with the specified role name.
     *
     * @param roleName the name of the role that was not found
     */
    public RoleNotFoundException(String roleName) {
        super(String.format("Role not found: %s", roleName));
        this.roleName = roleName;
    }

    /**
     * Gets the name of the role that was not found.
     *
     * @return the role name
     */
    public String getRoleName() {
        return roleName;
    }
}


==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/CTIMySQLFINAL/src/main/java/orsk/compli/exception/GlobalExceptionHandler.java
==============================
package orsk.compli.exception;

import org.springframework.dao.DataIntegrityViolationException;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.orm.jpa.JpaSystemException;
import org.springframework.web.bind.MethodArgumentNotValidException;
import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.ExceptionHandler;
import orsk.compli.exception.auth.BadRequestException;
import orsk.compli.exception.auth.ErrorResponse;
import orsk.compli.exception.auth.ResourceNotFoundException;
import orsk.compli.exception.auth.UserAlreadyExistsException;

import java.time.Instant;
import java.util.HashMap;
import java.util.Map;

@ControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(orsk.compli.exception.auth.ResourceNotFoundException.class)
    public ResponseEntity<orsk.compli.exception.auth.ErrorResponse> handleResourceNotFound(ResourceNotFoundException ex) {
        orsk.compli.exception.auth.ErrorResponse error = new orsk.compli.exception.auth.ErrorResponse(
                Instant.now(),
                HttpStatus.NOT_FOUND.value(),
                "Not Found",
                ex.getMessage()
        );
        return new ResponseEntity<>(error, HttpStatus.NOT_FOUND);
    }

    @ExceptionHandler(orsk.compli.exception.auth.BadRequestException.class)
    public ResponseEntity<orsk.compli.exception.auth.ErrorResponse> handleBadRequest(BadRequestException ex) {
        orsk.compli.exception.auth.ErrorResponse error = new orsk.compli.exception.auth.ErrorResponse(
                Instant.now(),
                HttpStatus.BAD_REQUEST.value(),
                "Bad Request",
                ex.getMessage()
        );
        return new ResponseEntity<>(error, HttpStatus.BAD_REQUEST);
    }

    @ExceptionHandler(Exception.class)
    public ResponseEntity<orsk.compli.exception.auth.ErrorResponse> handleGlobalException(Exception ex) {
        orsk.compli.exception.auth.ErrorResponse error = new ErrorResponse(
                Instant.now(),
                HttpStatus.INTERNAL_SERVER_ERROR.value(),
                "Internal Server Error",
                ex.getMessage()
        );
        return new ResponseEntity<>(error, HttpStatus.INTERNAL_SERVER_ERROR);
    }
    @ExceptionHandler({DataIntegrityViolationException.class})
    public ResponseEntity<?> handleDatabaseExceptions(DataIntegrityViolationException ex) {
        return ResponseEntity.badRequest().body("A database error occurred: " + ex.getMostSpecificCause().getMessage());
    }

    @ExceptionHandler({JpaSystemException.class})
    public ResponseEntity<?> handleJpaExceptions(JpaSystemException ex) {
        return ResponseEntity.internalServerError().body("A system error occurred: " + ex.getMostSpecificCause().getMessage());
    }

    @ExceptionHandler(UserAlreadyExistsException.class)
    public ResponseEntity<Map<String, String>> handleUserAlreadyExistsException(UserAlreadyExistsException ex) {
        Map<String, String> response = new HashMap<>();
        response.put("message", ex.getMessage());
        return ResponseEntity.status(HttpStatus.CONFLICT).body(response);
    }

    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<Map<String, String>> handleValidationException(MethodArgumentNotValidException ex) {
        Map<String, String> errors = new HashMap<>();
        ex.getBindingResult().getFieldErrors().forEach(error -> errors.put(error.getField(), error.getDefaultMessage()));
        return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(errors);
    }

}


==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/CTIMySQLFINAL/src/main/java/orsk/compli/exception/BadRequestException.java
==============================
package orsk.compli.exception;

public class BadRequestException extends RuntimeException {
    public BadRequestException(String message) {
        super(message);
    }
}




==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/CTIMySQLFINAL/src/main/java/orsk/compli/exception/EntityAlreadyExistsException.java
==============================
package orsk.compli.exception;

/**
 * Custom exception to handle cases where an entity already exists.
 */
public class EntityAlreadyExistsException extends RuntimeException {

    private static final long serialVersionUID = 1L;

    private final String entityName;
    private final Object identifier;

    /**
     * Constructs a new EntityAlreadyExistsException with the specified details.
     *
     * @param entityName the name of the entity
     * @param identifier the identifier of the existing entity
     */
    public EntityAlreadyExistsException(String entityName, Object identifier) {
        super(String.format("%s already exists with identifier: %s", entityName, identifier));
        this.entityName = entityName;
        this.identifier = identifier;
    }

    /**
     * Gets the name of the entity that already exists.
     *
     * @return the entity name
     */
    public String getEntityName() {
        return entityName;
    }

    /**
     * Gets the identifier of the entity that already exists.
     *
     * @return the identifier
     */
    public Object getIdentifier() {
        return identifier;
    }
}


==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/CTIMySQLFINAL/src/main/java/orsk/compli/exception/DatabaseOperationException.java
==============================
package orsk.compli.exception;

/**
 * Custom exception to handle database operation failures.
 */
public class DatabaseOperationException extends RuntimeException {

    private static final long serialVersionUID = 1L;

    private final String operation;
    private final String details;

    /**
     * Constructs a new DatabaseOperationException with the specified details.
     *
     * @param operation the database operation that failed
     * @param details   additional details about the failure
     */
    public DatabaseOperationException(String operation, String details) {
        super(String.format("Database operation '%s' failed: %s", operation, details));
        this.operation = operation;
        this.details = details;
    }

    /**
     * Gets the failed database operation.
     *
     * @return the operation name
     */
    public String getOperation() {
        return operation;
    }

    /**
     * Gets additional details about the failure.
     *
     * @return the details
     */
    public String getDetails() {
        return details;
    }
}


==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/CTIMySQLFINAL/src/main/java/orsk/compli/exception/InvalidTokenException.java
==============================
package orsk.compli.exception;

/**
 * Custom exception to handle invalid token scenarios.
 */
public class InvalidTokenException extends RuntimeException {

    private static final long serialVersionUID = 1L;

    private final String token;

    /**
     * Constructs a new InvalidTokenException with the specified token.
     *
     * @param token the invalid token
     */
    public InvalidTokenException(String token) {
        super(String.format("Invalid token: %s", token));
        this.token = token;
    }

    /**
     * Gets the invalid token.
     *
     * @return the invalid token
     */
    public String getToken() {
        return token;
    }
}


==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/CTIMySQLFINAL/src/main/java/orsk/compli/exception/ErrorResponse.java
==============================
package orsk.compli.exception;

import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.Setter;

import java.time.Instant;

@Getter
@Setter
@AllArgsConstructor
public class ErrorResponse {
    private Instant timestamp;
    private int status;
    private String error;
    private String message;
}




==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/CTIMySQLFINAL/src/main/java/orsk/compli/exception/UsernameOrEmailNotFoundException.java
==============================
package orsk.compli.exception;

import lombok.Getter;

/**
 * Custom exception to handle cases where a username or email is not found.
 * This exception extends RuntimeException, making it an unchecked exception.
 */
@Getter
public class UsernameOrEmailNotFoundException extends RuntimeException {

    private static final long serialVersionUID = 1L;

    /**
     * -- GETTER --
     *  Gets the input (username or email) that caused the exception.
     *
     * @return the input that was not found
     */
    private final String input;

    /**
     * Constructs a new UsernameOrEmailNotFoundException with the specified input.
     *
     * @param input the username or email that was not found
     */
    public UsernameOrEmailNotFoundException(String input) {
        super(String.format("User not found with username or email: %s", input));
        this.input = input;
    }

}


==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/CTIMySQLFINAL/src/main/java/orsk/compli/entities/RolesPrivilege.java
==============================
package orsk.compli.entities;

import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
@Entity
@Table(name = "roles_privileges", schema = "auth")
public class RolesPrivilege {
    @EmbeddedId
    private RolesPrivilegeId id;

    @MapsId("roleId")
    @ManyToOne(fetch = FetchType.LAZY, optional = false)
    @JoinColumn(name = "role_id", nullable = false)
    private Role role;

    @MapsId("privilegeId")
    @ManyToOne(fetch = FetchType.LAZY, optional = false)
    @JoinColumn(name = "privilege_id", nullable = false)
    private Privilege privilege;

}


==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/CTIMySQLFINAL/src/main/java/orsk/compli/entities/AffectedProduct.java
==============================
package orsk.compli.entities;

import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;
import org.hibernate.annotations.ColumnDefault;

import java.time.Instant;

@Getter
@Setter
@Entity
@Table(name = "affected_products")
public class AffectedProduct {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "product_id", nullable = false)
    private Integer id;

    @Column(name = "product_name", nullable = false)
    private String productName;

    @Column(name = "vendor")
    private String vendor;

    @Column(name = "version")
    private String version;

    @ColumnDefault("CURRENT_TIMESTAMP")
    @Column(name = "created_at")
    private Instant createdAt;

    @ColumnDefault("CURRENT_TIMESTAMP")
    @Column(name = "updated_at")
    private Instant updatedAt;
}


==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/CTIMySQLFINAL/src/main/java/orsk/compli/entities/Country.java
==============================
package orsk.compli.entities;

import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.Id;
import jakarta.persistence.Table;
import lombok.Getter;
import lombok.Setter;
import org.hibernate.annotations.ColumnDefault;

import java.time.Instant;

@Getter
@Setter
@Entity
@Table(name = "countries")
public class Country {
    @Id
    @Column(name = "country_code", nullable = false, length = 2)
    private String countryCode;

    @Column(name = "country_name", nullable = false, length = 100)
    private String countryName;

    @ColumnDefault("CURRENT_TIMESTAMP")
    @Column(name = "created_at")
    private Instant createdAt;

    @ColumnDefault("CURRENT_TIMESTAMP")
    @Column(name = "updated_at")
    private Instant updatedAt;

    public String getName() {
        return countryName;
    }

    public void setName(String name) {
        this.countryName = name;
    }
}


==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/CTIMySQLFINAL/src/main/java/orsk/compli/entities/RefreshToken.java
==============================
package orsk.compli.entities;

import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;

import java.time.Instant;

@Getter
@Setter
@Entity
@Table(name = "refresh_tokens", indexes = @Index(columnList = "token", unique = true))
public class RefreshToken {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false, unique = true)
    private String token;

    @Column(nullable = false, name = "expiry_date")
    private Instant expiryDate;

    @ManyToOne
    @JoinColumn(name = "user_id", nullable = false)
    private User user;
}


==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/CTIMySQLFINAL/src/main/java/orsk/compli/entities/MachineLearningFeature.java
==============================
package orsk.compli.entities;

import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;
import org.hibernate.annotations.ColumnDefault;
import org.hibernate.annotations.JdbcTypeCode;
import org.hibernate.annotations.OnDelete;
import org.hibernate.annotations.OnDeleteAction;
import org.hibernate.type.SqlTypes;

import java.time.Instant;
import java.util.Map;

@Getter
@Setter
@Entity
@Table(name = "machine_learning_features")
public class MachineLearningFeature {
    @Id
    @Column(name = "feature_id", nullable = false)
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY, optional = false)
    @OnDelete(action = OnDeleteAction.CASCADE)
    @JoinColumn(name = "incident_id", nullable = false)
    private IncidentLog incident;

    @Column(name = "feature_vector")
    @JdbcTypeCode(SqlTypes.JSON)
    private Map<String, Object> featureVector;

    @Column(name = "feature_name", nullable = false)
    private String featureName;

    @Column(name = "feature_value", nullable = false)
    private Double featureValue;

    @ColumnDefault("CURRENT_TIMESTAMP")
    @Column(name = "created_at")
    private Instant createdAt;

}


==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/CTIMySQLFINAL/src/main/java/orsk/compli/entities/UserRole.java
==============================
package orsk.compli.entities;

import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;
import org.hibernate.annotations.OnDelete;
import org.hibernate.annotations.OnDeleteAction;

@Getter
@Setter
@Entity
@Table(name = "user_roles")

public class UserRole {
    @Id
    @Column(name = "id", nullable = false)
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY, optional = false)
    @JoinColumn(name = "user_id", nullable = false)
    @OnDelete(action = OnDeleteAction.CASCADE)
    private User user;

    @Column(name = "role")
    private String role;

    @Column(name = "role_id", nullable = false)
    private Long roleId;



}


==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/CTIMySQLFINAL/src/main/java/orsk/compli/entities/PasswordResetToken.java
==============================
package orsk.compli.entities;

import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;

import java.time.Instant;

@Getter
@Setter
@Entity
@Table(name = "password_reset_tokens", indexes = @Index(columnList = "token", unique = true))
public class PasswordResetToken {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false, unique = true)
    private String token;

    @ManyToOne
    @JoinColumn(nullable = false, name = "user_id")
    private User user;

    @Column(nullable = false)
    private Instant expiryDate;
}


==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/CTIMySQLFINAL/src/main/java/orsk/compli/entities/FailedLogin.java
==============================
package orsk.compli.entities;

import jakarta.persistence.*;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Size;
import lombok.Getter;
import lombok.Setter;

import java.time.Instant;

@Getter
@Setter
@Entity
@Table(name = "failed_logins", schema = "auth")
public class FailedLogin {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "id", nullable = false)
    private Long id;

    @Size(max = 255)
    @NotNull
    @Column(name = "username", nullable = false)
    private String username;

    @Size(max = 255)
    @NotNull
    @Column(name = "ip_address", nullable = false)
    private String ipAddress;

    @NotNull
    @Column(name = "attempt_time", nullable = false)
    private Instant attemptTime;

    @Size(max = 500)
    @Column(name = "reason", length = 500)
    private String reason;

}


==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/CTIMySQLFINAL/src/main/java/orsk/compli/entities/AuditLog.java
==============================
package orsk.compli.entities;

import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;

import java.time.Instant;

@Getter
@Setter
@Entity
@Table(name = "audit_logs")
public class AuditLog {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false)
    private String action; // e.g., LOGIN_SUCCESS, LOGIN_FAILURE

    @Column(nullable = false)
    private String ipAddress;

    @Column(nullable = false)
    private Instant timestamp;

    @ManyToOne
    @JoinColumn(name = "user_id")
    private User user;

    @Column(length = 500)
    private String details;
}


==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/CTIMySQLFINAL/src/main/java/orsk/compli/entities/GlobalThreat.java
==============================
package orsk.compli.entities;

import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.Id;
import jakarta.persistence.Table;
import lombok.Getter;
import lombok.Setter;
import org.hibernate.annotations.ColumnDefault;

import java.time.Instant;
import java.time.LocalDate;

@Getter
@Setter
@Entity
@Table(name = "global_threats")
public class GlobalThreat {
    @Id
    @Column(name = "threat_id", nullable = false)
    private Integer id;

    @Column(name = "name", nullable = false)
    private String name;

    @Column(name = "description")
    private String description;

    @Column(name = "first_detected", nullable = false)
    private LocalDate firstDetected;

    @Column(name = "last_updated")
    private LocalDate lastUpdated;

    @ColumnDefault("0")
    @Column(name = "severity_level", nullable = false)
    private Integer severityLevel;

    @Column(name = "data_retention_until", nullable = false)
    private Instant dataRetentionUntil;

    @ColumnDefault("CURRENT_TIMESTAMP")
    @Column(name = "created_at")
    private Instant createdAt;

    @ColumnDefault("CURRENT_TIMESTAMP")
    @Column(name = "updated_at")
    private Instant updatedAt;

}


==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/CTIMySQLFINAL/src/main/java/orsk/compli/entities/MfaToken.java
==============================
package orsk.compli.entities;

import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;

import java.time.LocalDateTime;

@Getter
@Setter
@Entity
@Table(name = "mfa_tokens", indexes = @Index(columnList = "mfaCode", unique = true))
public class MfaToken {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false, unique = true)
    private String mfaCode;

    @Column(nullable = false)
    private LocalDateTime expiryDate;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "user_id", nullable = false)
    private User user;

    @Column(nullable = false)
    private Boolean used = false; // Default to false

    // Constructors, if needed
    public MfaToken() {}

    public MfaToken(String mfaCode, LocalDateTime expiryDate, User user) {
        this.mfaCode = mfaCode;
        this.expiryDate = expiryDate;
        this.user = user;
        this.used = false;
    }
}


==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/CTIMySQLFINAL/src/main/java/orsk/compli/entities/Privilege.java
==============================
package orsk.compli.entities;

import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;

import java.util.HashSet;
import java.util.Objects;
import java.util.Set;

@Getter
@Setter
@Entity
@Table(name = "privileges", indexes = @Index(columnList = "name", unique = true))
public class Privilege {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false, unique = true, length = 50)
    private String name;

    @ManyToMany(mappedBy = "privileges", fetch = FetchType.LAZY)
    private Set<Role> roles = new HashSet<>();

    // Override equals and hashCode based on 'name'
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Privilege privilege = (Privilege) o;
        return Objects.equals(name, privilege.name);
    }

    @Override
    public int hashCode() {
        return Objects.hash(name);
    }
}


==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/CTIMySQLFINAL/src/main/java/orsk/compli/entities/TimeSeriesAnalytic.java
==============================
package orsk.compli.entities;

import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;

import java.time.LocalDate;

@Getter
@Setter
@Entity
@Table(name = "time_series_analytics")
public class TimeSeriesAnalytic {
    @Id
    @Column(name = "time_series_id", nullable = false)
    private Long id;

    @Column(name = "analysis_date", nullable = false)
    private LocalDate analysisDate;

    @Column(name = "metric", nullable = false)
    private String metric;

    @Column(name = "value", nullable = false)
    private Double value;

    @ManyToOne(fetch = FetchType.LAZY, optional = false)
    @JoinColumn(name = "incident_id", nullable = false)
    private IncidentLog incident;

}


==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/CTIMySQLFINAL/src/main/java/orsk/compli/entities/IncidentLog.java
==============================
package orsk.compli.entities;

import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;
import org.hibernate.annotations.ColumnDefault;
import org.hibernate.annotations.OnDelete;
import org.hibernate.annotations.OnDeleteAction;

import java.time.Instant;

@Getter
@Setter
@Entity
@Table(name = "incident_logs")
public class IncidentLog {
    @Id
    @Column(name = "incident_id", nullable = false)
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY, optional = false)
    @JoinColumn(name = "actor_id", nullable = false)
    private ThreatActor actor;

    @ManyToOne(fetch = FetchType.LAZY, optional = false)
    @JoinColumn(name = "vector_id", nullable = false)
    private AttackVector vector;

    @ManyToOne(fetch = FetchType.LAZY)
    @OnDelete(action = OnDeleteAction.SET_NULL)
    @JoinColumn(name = "vulnerability_id")
    private Vulnerability vulnerability;

    @ManyToOne(fetch = FetchType.LAZY, optional = false)
    @JoinColumn(name = "geolocation_id", nullable = false)
    private GeolocationDatum geolocation;

    @Column(name = "incident_date", nullable = false)
    private Instant incidentDate;

    @Column(name = "target", nullable = false)
    private String target;

    @ManyToOne(fetch = FetchType.LAZY, optional = false)
    @JoinColumn(name = "industry_id", nullable = false)
    private Industry industry;

    @Column(name = "impact")
    private String impact;

    @Column(name = "response")
    private String response;

    @Column(name = "response_date")
    private Instant responseDate;

    @Column(name = "data_retention_until", nullable = false)
    private Instant dataRetentionUntil;

    @ColumnDefault("CURRENT_TIMESTAMP")
    @Column(name = "created_at")
    private Instant createdAt;

    @ColumnDefault("CURRENT_TIMESTAMP")
    @Column(name = "updated_at")
    private Instant updatedAt;

    @Column(name = "industry")
    private String industry1;

}


==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/CTIMySQLFINAL/src/main/java/orsk/compli/entities/User.java
==============================
package orsk.compli.entities;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

import java.util.HashSet;
import java.util.Set;

@Getter
@Setter
@Entity
@AllArgsConstructor
@Table(name = "users", indexes = {
        @Index(columnList = "username", unique = true),
        @Index(columnList = "email", unique = true)
})
@NoArgsConstructor
public class User {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false, unique = true, length = 50)
    private String username;

    @Version
    private Integer version;

    @Column(nullable = false, length = 100)
    private String password;

    @Column(nullable = false, unique = true, length = 255)
    private String email;

    @Column(nullable = false)
    private Boolean enabled = false;

    @Column(nullable = false, name = "consent_to_data_usage")
    private Boolean consentToDataUsage = false;

    @ManyToMany(fetch = FetchType.EAGER, cascade = {CascadeType.PERSIST, CascadeType.MERGE})
    @JoinTable(
            name = "user_roles",
            joinColumns = @JoinColumn(name = "user_id"),
            inverseJoinColumns = @JoinColumn(name = "role_id")
    )
    private Set<Role> roles = new HashSet<>(); // Ensure roles is always mutable

    // Other fields and relationships...

    @OneToMany(mappedBy = "user", cascade = CascadeType.ALL, fetch = FetchType.LAZY)
    private Set<RefreshToken> refreshTokens = new HashSet<>();

    @OneToMany(mappedBy = "user", cascade = CascadeType.ALL, fetch = FetchType.LAZY)
    private Set<PasswordResetToken> passwordResetTokens = new HashSet<>();

    @OneToMany(mappedBy = "user", cascade = CascadeType.ALL, fetch = FetchType.LAZY)
    private Set<VerificationToken> verificationTokens = new HashSet<>();

    @OneToMany(mappedBy = "user", cascade = CascadeType.ALL, fetch = FetchType.LAZY)
    private Set<MfaToken> mfaTokens = new HashSet<>();

    @OneToMany(mappedBy = "user", cascade = CascadeType.ALL, fetch = FetchType.LAZY)
    private Set<AuditLog> auditLogs = new HashSet<>();

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "tenant_id")
    private Tenant tenant;



    @PreRemove
    private void preRemove() {
        roles.clear();
    }

    public User(String username, String email, String password, Boolean enabled, Set<Role> roles) {
        this.username = username;
        this.email = email;
        this.password = password;
        this.enabled = enabled;
        this.roles = roles;
    }
}


==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/CTIMySQLFINAL/src/main/java/orsk/compli/entities/ThreatPrediction.java
==============================
package orsk.compli.entities;

import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;
import org.hibernate.annotations.ColumnDefault;
import org.hibernate.annotations.OnDelete;
import org.hibernate.annotations.OnDeleteAction;

import java.time.Instant;
import java.time.LocalDate;

@Getter
@Setter
@Entity
@Table(name = "threat_predictions")
public class ThreatPrediction {
    @Id
    @Column(name = "prediction_id", nullable = false)
    private Long id;

    @Column(name = "prediction_date", nullable = false)
    private LocalDate predictionDate;

    @ManyToOne(fetch = FetchType.LAZY, optional = false)
    @OnDelete(action = OnDeleteAction.CASCADE)
    @JoinColumn(name = "threat_id", nullable = false)
    private GlobalThreat threat;

    @Column(name = "probability", nullable = false)
    private Double probability;

    @Column(name = "predicted_impact")
    private String predictedImpact;

    @Column(name = "data_retention_until", nullable = false)
    private Instant dataRetentionUntil;

    @ColumnDefault("CURRENT_TIMESTAMP")
    @Column(name = "created_at")
    private Instant createdAt;

}


==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/CTIMySQLFINAL/src/main/java/orsk/compli/entities/ThreatActorType.java
==============================
package orsk.compli.entities;

import jakarta.persistence.*;
import lombok.Data;
import lombok.Getter;
import lombok.Setter;
import org.hibernate.annotations.ColumnDefault;

import java.time.Instant;

@Getter
@Setter
@Data
@Entity
@Table(name = "threat_actor_types")
public class ThreatActorType {
    @Id
    @Column(name = "type_id", nullable = false)
    private Integer id;

    @Column(name = "type_name", nullable = false, length = 100)
    private String typeName;

    @Lob
    @Column(name = "description")
    private String description;

    @ColumnDefault("CURRENT_TIMESTAMP")
    @Column(name = "created_at")
    private Instant createdAt;

    @ColumnDefault("CURRENT_TIMESTAMP")
    @Column(name = "updated_at")
    private Instant updatedAt;

}


==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/CTIMySQLFINAL/src/main/java/orsk/compli/entities/VerificationToken.java
==============================
package orsk.compli.entities;

import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;

import java.time.Instant;

@Getter
@Setter
@Entity
@Table(name = "verification_tokens", indexes = @Index(columnList = "token", unique = true))
public class VerificationToken {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false, unique = true)
    private String token;

    @ManyToOne
    @JoinColumn(nullable = false, name = "user_id")
    private User user;

    @Column(nullable = false)
    private Instant expiryDate;
}


==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/CTIMySQLFINAL/src/main/java/orsk/compli/entities/VulnerabilityProductAssociation.java
==============================
package orsk.compli.entities;

import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;
import org.hibernate.annotations.OnDelete;
import org.hibernate.annotations.OnDeleteAction;

@Getter
@Setter
@Entity
@Table(name = "vulnerability_product_association")
public class VulnerabilityProductAssociation {
    @EmbeddedId
    private VulnerabilityProductAssociationId id;

    @MapsId("vulnerabilityId")
    @ManyToOne(fetch = FetchType.LAZY, optional = false)
    @OnDelete(action = OnDeleteAction.CASCADE)
    @JoinColumn(name = "vulnerability_id", nullable = false)
    private Vulnerability vulnerability;

    @MapsId("productId")
    @ManyToOne(fetch = FetchType.LAZY, optional = false)
    @OnDelete(action = OnDeleteAction.CASCADE)
    @JoinColumn(name = "product_id", nullable = false)
    private AffectedProduct product;

}


==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/CTIMySQLFINAL/src/main/java/orsk/compli/entities/AttackVector.java
==============================
package orsk.compli.entities;

import com.fasterxml.jackson.annotation.JsonBackReference;
import com.fasterxml.jackson.annotation.JsonIdentityInfo;
import com.fasterxml.jackson.annotation.ObjectIdGenerators;
import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;
import org.hibernate.annotations.ColumnDefault;

import java.time.Instant;
import java.util.HashSet;
import java.util.Set;

@Getter
@Setter
@Entity
@Table(name = "attack_vectors")
@JsonIdentityInfo(generator = ObjectIdGenerators.PropertyGenerator.class, property = "id")

public class AttackVector {
    @Id
    @Column(name = "vector_id", nullable = false)
    private Integer id;

    @Column(name = "vector_name", nullable = false)
    private String vectorName;

    @Column(name = "description")
    private String description;

    @ManyToOne(fetch = FetchType.LAZY, optional = false)
    @JoinColumn(name = "vector_category_id", nullable = false)
    private AttackVectorCategory vectorCategory;

    @Column(name = "severity_level")
    private Integer severityLevel;

    @ColumnDefault("CURRENT_TIMESTAMP")
    @Column(name = "created_at")
    private Instant createdAt;

    @ColumnDefault("CURRENT_TIMESTAMP")
    @Column(name = "updated_at")
    private Instant updatedAt;

    @Column(name = "category")
    private String category;

    @ManyToMany(mappedBy = "attackVectors")
    @JsonBackReference
    private Set<ThreatActor> threatActors = new HashSet<>();
}


==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/CTIMySQLFINAL/src/main/java/orsk/compli/entities/Device.java
==============================
package orsk.compli.entities;

import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;

import java.time.Instant;

@Getter
@Setter
@Entity
@Table(name = "devices")
public class Device {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false)
    private String deviceId;

    @Column(nullable = false)
    private String deviceType; // e.g., MOBILE, DESKTOP

    @Column(nullable = false)
    private Instant registeredAt;

    @ManyToOne
    @JoinColumn(name = "user_id", nullable = false)
    private User user;
}


==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/CTIMySQLFINAL/src/main/java/orsk/compli/entities/ThreatCategory.java
==============================
package orsk.compli.entities;

import jakarta.persistence.*;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;
import lombok.Getter;
import lombok.Setter;
import org.hibernate.annotations.CreationTimestamp;
import org.hibernate.annotations.UpdateTimestamp;

import java.time.Instant;
import java.util.Set;

@Getter
@Setter
@Entity
@Table(name = "threat_categories", uniqueConstraints = {
        @UniqueConstraint(columnNames = "category_name", name = "unique_category_name")
})
public class ThreatCategory {

    @Id
    @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "threat_category_seq")
    @SequenceGenerator(name = "threat_category_seq", sequenceName = "threat_category_seq", allocationSize = 1)
    @Column(name = "category_id", nullable = false)
    private Integer id;

    @NotBlank
    @Size(max = 100, message = "Category name cannot exceed 100 characters")
    @Column(name = "category_name", nullable = false, length = 100)
    private String categoryName;

    @Size(max = 500, message = "Description cannot exceed 500 characters")
    @Column(name = "description", length = 500)
    private String description;

    @CreationTimestamp
    @Column(name = "created_at", updatable = false)
    private Instant createdAt;

    @UpdateTimestamp
    @Column(name = "updated_at")
    private Instant updatedAt;

    @OneToMany(mappedBy = "category", cascade = CascadeType.ALL, orphanRemoval = true)
    private Set<ThreatActor> threatActors;
}


==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/CTIMySQLFINAL/src/main/java/orsk/compli/entities/ThreatActor.java
==============================
package orsk.compli.entities;

import com.fasterxml.jackson.annotation.JsonIdentityInfo;
import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import com.fasterxml.jackson.annotation.JsonManagedReference;
import com.fasterxml.jackson.annotation.ObjectIdGenerators;
import jakarta.persistence.*;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Size;
import lombok.Getter;
import lombok.Setter;
import org.hibernate.annotations.CreationTimestamp;
import org.hibernate.annotations.UpdateTimestamp;
import orsk.compli.dtos.jpa.ThreatActorDTO;

import java.time.Instant;
import java.time.LocalDate;
import java.util.HashSet;
import java.util.Set;

@Getter
@Setter
@Entity
@Table(name = "threat_actors")
@JsonIdentityInfo(generator = ObjectIdGenerators.PropertyGenerator.class, property = "id")
@JsonIgnoreProperties( ignoreUnknown = true, value = {
        "hibernateLazyInitializer",
        "handler",
        "byteBuddyInterceptor"


})
public class ThreatActor extends ThreatActorDTO {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "actor_id", nullable = false, updatable = false)
    private Integer id;

    @NotBlank
    @Size(max = 255)
    @Column(name = "actor_name", nullable = false, unique = true)
    private String actorName;

    @Size(max = 500)
    @Column(name = "motivation")
    private String motivation;

    @Size(max = 500)
    @Column(name = "capabilities")
    private String capabilities;

    @NotNull
    @ManyToOne(fetch = FetchType.LAZY, cascade = CascadeType.PERSIST, optional = false)
    @JoinColumn(name = "type_id", nullable = false)
    private ThreatActorType type;

    @Size(max = 2000)
    @Column(name = "description")
    private String description;

    @NotNull
    @ManyToOne(fetch = FetchType.LAZY, cascade = CascadeType.PERSIST, optional = false)
    @JoinColumn(name = "origin_country", nullable = false)
    private Country originCountry;

    @NotNull
    @Column(name = "first_observed", nullable = false)
    private LocalDate firstObserved;

    @Column(name = "last_activity")
    private LocalDate lastActivity;

    @NotNull
    @ManyToOne(fetch = FetchType.LAZY, cascade = CascadeType.PERSIST, optional = false)
    @JoinColumn(name = "category_id", nullable = false)
    private ThreatCategory category;

    @CreationTimestamp
    @Column(name = "created_at", nullable = false, updatable = false)
    private Instant createdAt;

    @UpdateTimestamp
    @Column(name = "updated_at", nullable = false)
    private Instant updatedAt;

    @ManyToMany(cascade = {CascadeType.PERSIST, CascadeType.MERGE})
    @JoinTable(
            name = "threat_actor_attack_vector",
            joinColumns = @JoinColumn(name = "threat_actor_id"),
            inverseJoinColumns = @JoinColumn(name = "attack_vector_id")
    )
    @JsonManagedReference
    private Set<AttackVector> attackVectors = new HashSet<>();

    public void addAttackVector(AttackVector attackVector) {
        this.attackVectors.add(attackVector);
        attackVector.getThreatActors().add(this);
    }

    public void removeAttackVector(AttackVector attackVector) {
        this.attackVectors.remove(attackVector);
        attackVector.getThreatActors().remove(this);
    }

    @PrePersist
    private void validateBeforePersist() {
        if (actorName == null || actorName.isBlank()) {
            throw new IllegalArgumentException("Actor name is mandatory and cannot be blank");
        }
        if (firstObserved == null) {
            throw new IllegalArgumentException("First observed date is mandatory");
        }
        if (type == null) {
            throw new IllegalArgumentException("Actor type is mandatory");
        }
        if (originCountry == null) {
            throw new IllegalArgumentException("Origin country is mandatory");
        }
        if (category == null) {
            throw new IllegalArgumentException("Category is mandatory");
        }
    }
}


==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/CTIMySQLFINAL/src/main/java/orsk/compli/entities/Role.java
==============================
package orsk.compli.entities;

import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;

import java.util.HashSet;
import java.util.Objects;
import java.util.Set;

@Getter
@Setter
@Entity
@Table(name = "roles", indexes = {
        @Index(columnList = "name", unique = true)
})
public class Role {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false, unique = true, length = 50)
    private String name;

    @ManyToMany(fetch = FetchType.LAZY)
    @JoinTable(
            name = "roles_privileges",
            joinColumns = @JoinColumn(name = "role_id"),
            inverseJoinColumns = @JoinColumn(name = "privilege_id")
    )
    private Set<Privilege> privileges = new HashSet<>();

    // Override equals and hashCode based on 'name'
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Role role = (Role) o;
        return Objects.equals(name, role.name);
    }


    @Override
    public int hashCode() {
        return Objects.hash(name);
    }
}


==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/CTIMySQLFINAL/src/main/java/orsk/compli/entities/StatisticalReport.java
==============================
package orsk.compli.entities;

import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.Id;
import jakarta.persistence.Table;
import lombok.Getter;
import lombok.Setter;

import java.time.LocalDate;

@Getter
@Setter
@Entity
@Table(name = "statistical_reports")
public class StatisticalReport {
    @Id
    @Column(name = "report_id", nullable = false)
    private Long id;

    @Column(name = "content")
    private String content;

    @Column(name = "generated_date", nullable = false)
    private LocalDate generatedDate;

    @Column(name = "report_type", nullable = false)
    private String reportType;

}


==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/CTIMySQLFINAL/src/main/java/orsk/compli/entities/Tenant.java
==============================
package orsk.compli.entities;

import jakarta.persistence.*;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Size;
import lombok.Getter;
import lombok.Setter;

import java.util.LinkedHashSet;
import java.util.Set;

@Getter
@Setter
@Entity
@Table(name = "tenants", schema = "auth")
public class Tenant {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "id", nullable = false)
    private Long id;

    @Size(max = 255)
    @NotNull
    @Column(name = "name", nullable = false)
    private String name;

    @OneToMany(mappedBy = "tenant")
    private Set<User> users = new LinkedHashSet<>();

}


==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/CTIMySQLFINAL/src/main/java/orsk/compli/entities/Vulnerability.java
==============================
package orsk.compli.entities;

import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;
import org.hibernate.annotations.ColumnDefault;

import java.math.BigDecimal;
import java.time.Instant;
import java.time.LocalDate;

@Getter
@Setter
@Entity
@Table(name = "vulnerabilities")
public class Vulnerability {
    @Id
    @Column(name = "vulnerability_id", nullable = false)
    private Integer id;

    @Column(name = "cve_id", nullable = false, length = 20)
    private String cveId;

    @Column(name = "name", nullable = false, length = 20)
    private String name;

    @Column(name = "severity", nullable = false, length = 20)
    private int severity;


    @Lob
    @Column(name = "description", nullable = false)
    private String description;

    @Column(name = "published_date", nullable = false)
    private LocalDate publishedDate;

    @Column(name = "severity_score", nullable = false, precision = 4, scale = 1)
    private BigDecimal severityScore;

    @ColumnDefault("CURRENT_TIMESTAMP")
    @Column(name = "created_at")
    private Instant createdAt;

    @ColumnDefault("CURRENT_TIMESTAMP")
    @Column(name = "updated_at")
    private Instant updatedAt;
}


==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/CTIMySQLFINAL/src/main/java/orsk/compli/entities/GeolocationDatum.java
==============================
package orsk.compli.entities;

import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.Id;
import jakarta.persistence.Table;
import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
@Entity
@Table(name = "geolocation_data")
public class GeolocationDatum {
    @Id
    @Column(name = "geolocation_id", nullable = false)
    private Long id;

    @Column(name = "city")
    private String city;

    @Column(name = "country")
    private String country;

    @Column(name = "ip_address", nullable = false)
    private String ipAddress;

    @Column(name = "latitude")
    private Double latitude;

    @Column(name = "longitude")
    private Double longitude;

    @Column(name = "region")
    private String region;

}


==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/CTIMySQLFINAL/src/main/java/orsk/compli/entities/Geolocation.java
==============================
package orsk.compli.entities;

import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;
import org.hibernate.annotations.ColumnDefault;

import java.math.BigDecimal;
import java.time.Instant;

@Getter
@Setter
@Entity
@Table(name = "geolocations")
public class Geolocation {
    @Id
    @Column(name = "geolocation_id", nullable = false)
    private Long id;

    @Column(name = "ip_address", nullable = false, length = 16)
    private String ipAddress;

    @ManyToOne(fetch = FetchType.LAZY, optional = false)
    @JoinColumn(name = "country", nullable = false)
    private Country country;

    @Column(name = "region", length = 100)
    private String region;

    @Column(name = "city", length = 100)
    private String city;

    @Column(name = "latitude", precision = 9, scale = 6)
    private BigDecimal latitude;

    @Column(name = "longitude", precision = 9, scale = 6)
    private BigDecimal longitude;

    @ColumnDefault("CURRENT_TIMESTAMP")
    @Column(name = "created_at")
    private Instant createdAt;

    @ColumnDefault("CURRENT_TIMESTAMP")
    @Column(name = "updated_at")
    private Instant updatedAt;

}


==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/CTIMySQLFINAL/src/main/java/orsk/compli/entities/Session.java
==============================
package orsk.compli.entities;

import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;

import java.time.Instant;

@Getter
@Setter
@Entity
@Table(name = "sessions", indexes = @Index(columnList = "sessionId", unique = true))
public class Session {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false, unique = true)
    private String sessionId;

    @Column(nullable = false)
    private Instant createdAt;

    @Column(nullable = false)
    private Instant lastAccessedAt;

    @ManyToOne
    @JoinColumn(name = "user_id", nullable = false)
    private User user;
}


==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/CTIMySQLFINAL/src/main/java/orsk/compli/entities/RolesPrivilegeId.java
==============================
package orsk.compli.entities;

import jakarta.persistence.Column;
import jakarta.persistence.Embeddable;
import jakarta.validation.constraints.NotNull;
import lombok.Getter;
import lombok.Setter;
import org.hibernate.Hibernate;

import java.util.Objects;

@Getter
@Setter
@Embeddable
public class RolesPrivilegeId implements java.io.Serializable {
    private static final long serialVersionUID = -2271953843273908303L;
    @NotNull
    @Column(name = "role_id", nullable = false)
    private Long roleId;

    @NotNull
    @Column(name = "privilege_id", nullable = false)
    private Long privilegeId;

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || Hibernate.getClass(this) != Hibernate.getClass(o)) return false;
        RolesPrivilegeId entity = (RolesPrivilegeId) o;
        return Objects.equals(this.privilegeId, entity.privilegeId) &&
                Objects.equals(this.roleId, entity.roleId);
    }

    @Override
    public int hashCode() {
        return Objects.hash(privilegeId, roleId);
    }

}


==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/CTIMySQLFINAL/src/main/java/orsk/compli/entities/AttackVectorCategory.java
==============================
package orsk.compli.entities;

import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;
import org.hibernate.annotations.ColumnDefault;

import java.time.Instant;

@Getter
@Setter
@Entity
@Table(name = "attack_vector_categories")
public class AttackVectorCategory {
    @Id
    @Column(name = "vector_category_id", nullable = false)
    private Integer id;

    @Column(name = "category_name", nullable = false, length = 100)
    private String categoryName;

    @Lob
    @Column(name = "description")
    private String description;

    @ColumnDefault("CURRENT_TIMESTAMP")
    @Column(name = "created_at")
    private Instant createdAt;

    @ColumnDefault("CURRENT_TIMESTAMP")
    @Column(name = "updated_at")
    private Instant updatedAt;

}


==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/CTIMySQLFINAL/src/main/java/orsk/compli/entities/VulnerabilityProductAssociationId.java
==============================
package orsk.compli.entities;

import jakarta.persistence.Column;
import jakarta.persistence.Embeddable;
import lombok.Getter;
import lombok.Setter;
import org.hibernate.Hibernate;

import java.io.Serial;
import java.util.Objects;

@Getter
@Setter
@Embeddable
public class VulnerabilityProductAssociationId implements java.io.Serializable {
    @Serial
    private static final long serialVersionUID = 7165693539974467964L;
    @Column(name = "vulnerability_id", nullable = false)
    private Integer vulnerabilityId;

    @Column(name = "product_id", nullable = false)
    private Integer productId;

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || Hibernate.getClass(this) != Hibernate.getClass(o)) return false;
        VulnerabilityProductAssociationId entity = (VulnerabilityProductAssociationId) o;
        return Objects.equals(this.vulnerabilityId, entity.vulnerabilityId) &&
                Objects.equals(this.productId, entity.productId);
    }

    @Override
    public int hashCode() {
        return Objects.hash(vulnerabilityId, productId);
    }

}


==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/CTIMySQLFINAL/src/main/java/orsk/compli/entities/Industry.java
==============================
package orsk.compli.entities;

import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;
import org.hibernate.annotations.ColumnDefault;

import java.time.Instant;

@Getter
@Setter
@Entity
@Table(name = "industries")
public class Industry {
    @Id
    @Column(name = "industry_id", nullable = false)
    private Integer id;

    @Column(name = "industry_name", nullable = false, length = 100)
    private String industryName;

    @Lob
    @Column(name = "description")
    private String description;

    @ColumnDefault("CURRENT_TIMESTAMP")
    @Column(name = "created_at")
    private Instant createdAt;

    @ColumnDefault("CURRENT_TIMESTAMP")
    @Column(name = "updated_at")
    private Instant updatedAt;

}


==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/CTIMySQLFINAL/src/main/java/orsk/compli/CompliMySqlApplication.java
==============================
package orsk.compli;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class CompliMySqlApplication {

    public static void main(String[] args) {
        SpringApplication.run(CompliMySqlApplication.class, args);
    }

}



